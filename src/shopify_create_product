import os, json, requests, yaml

# ---------- boilerplate (same style you’re using) ----------
def normalize_myshopify_domain(raw: str) -> str:
    s = (raw or "").strip()
    s = s.replace("https://", "").replace("http://", "").split("/")[0]
    if s.endswith(".myshopify.com"):
        s = s[: -len(".myshopify.com")]
    return f"{s}.myshopify.com"

def load_credentials_from_yaml(item):
    with open("/Users/johnmikedidonato/Projects/TheShapesOfStories/config.yaml", "r") as yaml_file:
        config = yaml.safe_load(yaml_file)
    return config[item]

SHOP_DOMAIN = normalize_myshopify_domain(load_credentials_from_yaml('shopify_url'))
TOKEN = load_credentials_from_yaml('shopify_key')
API_VERSION = "2025-10"
GQL_URL = f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/graphql.json"
HEADERS = {"X-Shopify-Access-Token": TOKEN, "Content-Type": "application/json"}

def gql(query: str, variables: dict = None):
    r = requests.post(GQL_URL, headers=HEADERS, json={"query": query, "variables": variables or {}})
    r.raise_for_status()
    data = r.json()
    if "errors" in data:
        raise RuntimeError(json.dumps(data["errors"], indent=2))
    return data["data"]

# ---------- mutations ----------
MUT_PRODUCT_CREATE = """
mutation($input: ProductInput!) {
  productCreate(input: $input) {
    product { id handle title status }
    userErrors { field message }
  }
}
"""


MUT_METAFIELDS_SET = """
mutation($metafields: [MetafieldsSetInput!]!) {
  metafieldsSet(metafields: $metafields) {
    metafields { id namespace key type value }  # removed ownerId
    userErrors { field message }
  }
}
"""


# ---------- type map for YOUR product metafields ----------
PRODUCT_TYPE_MAP = {
  # story.*
  "story.title": "single_line_text_field",
  "story.protagonist": "single_line_text_field",
  "story.slug": "single_line_text_field",
  "story.year": "number_integer",
  "story.type": "single_line_text_field",
  "story.manual_collections": "list.single_line_text_field",

  # shape.*
  "shape.symbolic_representation": "single_line_text_field",
  "shape.archetype": "single_line_text_field",

  # literature.*
  "literature.author": "single_line_text_field",
  "literature.genres": "list.single_line_text_field",
  "literature.themes": "list.single_line_text_field",
  "literature.settings": "list.single_line_text_field",
  "literature.countries": "list.single_line_text_field",
  "literature.series_or_universe": "list.single_line_text_field",
  "literature.awards": "list.single_line_text_field",
  "literature.primary_isbns": "list.single_line_text_field",
}

def _coerce_value(dotted_key: str, value):
    """Return the correct string payload for metafieldsSet.value based on type."""
    mtype = PRODUCT_TYPE_MAP[dotted_key]
    if mtype.startswith("list."):
        # value must be a JSON array string
        return json.dumps(value if isinstance(value, list) else [value])
    # numbers still get passed as strings to GraphQL metafieldsSet
    return str(value)

def set_product_metafields(product_id: str, values: dict):
    """values = {'ns.key': python_value, ...}"""
    mf_inputs = []
    for dotted_key, val in values.items():
        if dotted_key not in PRODUCT_TYPE_MAP:
            raise ValueError(f"Unknown metafield key (no definition or not in map): {dotted_key}")
        ns, key = dotted_key.split(".", 1)
        mf_inputs.append({
            "ownerId": product_id,
            "namespace": ns,
            "key": key,
            "type": PRODUCT_TYPE_MAP[dotted_key],
            "value": _coerce_value(dotted_key, val),
        })
    # Chunk to 25 if you like; your set is under 25 so one call is fine.
    res = gql(MUT_METAFIELDS_SET, {"metafields": mf_inputs})["metafieldsSet"]
    if res["userErrors"]:
        raise RuntimeError(res["userErrors"])
    return res["metafields"]


MUT_PRODUCT_OPTIONS_CREATE = """
mutation($productId: ID!, $options: [OptionCreateInput!]!) {
  productOptionsCreate(productId: $productId, options: $options) {
    product {
      id
      options { name position values optionValues { id name hasVariants } }
    }
    userErrors { field message code }
  }
}
"""

def set_product_options(product_id: str, option_names):
    # API requires at least one value per option. Seed with a placeholder;
    # you can overwrite via productVariantsBulkCreate later.
    opts = []
    for idx, name in enumerate(option_names, start=1):
        opts.append({
            "name": name,
            "position": idx,
            "values": [{"name": "_"}],  # minimal seed value
        })
    res = gql(MUT_PRODUCT_OPTIONS_CREATE, {"productId": product_id, "options": opts})["productOptionsCreate"]
    if res["userErrors"]:
        raise RuntimeError(res["userErrors"])
    return res["product"]["options"]



def create_product_and_set_metafields(product_input: dict, metafields: dict, option_names=None):
    # create product
    data = gql(MUT_PRODUCT_CREATE, {"input": product_input})["productCreate"]
    if data["userErrors"]:
        raise RuntimeError(data["userErrors"])
    product = data["product"]
    pid = product["id"]
    print(f"✅ Created product: {pid}  handle={product['handle']}")

    # set options (Color/Style/Size)
    if option_names:
        set_product_options(pid, option_names)
        print(f"✅ Set product options: {', '.join(option_names)}")

    # set metafields
    if metafields:
        set_product_metafields(pid, metafields)
        print(f"✅ Set {len(metafields)} product metafields")

    return pid



def create_shopify_product(story_data_path, product_type):

    #open story data
    with open(story_data_path, 'r') as f:
        story_data = json.load(f)
    
    #SET SHOPIFY CORE PRODUCT FIELDS
    product_title = story_data['title'] + " — " + story_data['protagonist'] + "'s Journey"
    product_handle = story_data['story_slug'] + "-" + product_type
    #product_status = ?
    product_description = story_data['story_full_product_description_html']
    product_vendor = "The Shapes of Stories"
    productType = product_type
    #tags
    if product_type == "print":
        product_options = ["Color", "Style", "Size"]
        product_tags = []
        product_tags.append("Title: " + story_data['title']) 
        product_tags.append(f"Author: {story_data['author']}")
        product_tags.append(f"Protagonist: {story_data['protagonist']}")
        product_tags.append(f"Year: {story_data['year']}")
        product_tags.append(f"Story Type: {story_data['story_type']}")
        product_tags.append(f"Shape: {story_data['shape_symbolic_representation']}")
        product_tags.append(f"Shape Archetype: {story_data['shape_archetype']}")
        product_tags.append(f"Type: {product_type}")             # e.g., Print
        # product_tags.append(f"Style: {style}")                 # if you have it

        md = story_data.get("metadata", {})
        for g in md.get("genres", []):   product_tags.append(f"Genre: {g}")
        for t in md.get("themes", []):   product_tags.append(f"Theme: {t}")
        for s in md.get("settings", []): product_tags.append(f"Setting: {s}")
        for c in md.get("associated_countries", []): product_tags.append(f"Country: {c}")
        for sr in md.get("series_or_universe", []):  product_tags.append(f"Series: {sr}")
        for aw in md.get("awards", []):  product_tags.append(f"Award: {aw}")

    else:
        print("❌ ERROR: Product Type: ", product_type, " NOT supported!")
        return 
    
    product_input = {
        "title": product_title,
        "handle": product_handle,
        "descriptionHtml": product_description,
        "vendor": product_vendor,
        "productType": productType,
        "tags": product_tags,
        "status": "DRAFT" #set it to DRAFT so I will manually inspect and then make it ACTIVE
    }

    #SET SHOPIFY PRODUCT METAFIELDS THAT APPLY TO ALL STORY TYPES
    basic_product_metafields = {
        "story.title": story_data['title'],
        "story.protagonist": story_data['protagonist'],
        "story.slug": story_data['story_slug'],
        "story.year": story_data['year'],
        "story.type": story_data['story_type'],
        "story.manual_collections": [],

        "shape.symbolic_representation": story_data['shape_symbolic_representation'],
        "shape.archetype": story_data['shape_archetype']
    }

    #SET SHOPIFY PRODUCT METAFIELDS THAT ARE STORY SPECIFIC 
    if story_data['story_type'] == "Literature":
        story_specific_product_metafields = {
            "literature.author": story_data['author'],
            "literature.genres": story_data['metadata']['genres'],
            "literature.themes": story_data['metadata']['themes'],
            "literature.settings": story_data['metadata']['settings'],
            "literature.countries":  story_data['metadata']['associated_countries'],
            "literature.series_or_universe": story_data['metadata']['series_or_universe'],
            "literature.awards": story_data['metadata']['awards'],
            "literature.primary_isbns": story_data['metadata']['primary_isbns'],
        }
        
    else:
        print("❌ ERROR: Story Type: ", story_data['story_type'], " NOT supported!")
        return 
    
    #combine basic and story specific metafields
    product_metafields = basic_product_metafields | story_specific_product_metafields

    create_product_and_set_metafields(product_input, product_metafields, product_options)

story_data_path = "/Users/johnmikedidonato/Library/CloudStorage/GoogleDrive-johnmike@theshapesofstories.com/My Drive/story_data/the-stranger-meursault.json"
create_shopify_product(story_data_path, "print")

# ---------- example usage ----------
# if __name__ == "__main__":
#     product_input = {
#         "title": "The Great Gatsby — 11x14 Poster",
#         "status": "DRAFT",
#         "descriptionHtml": "<p>Jay Gatsby’s emotional arc, visualized.</p>",
#         "vendor": "The Shapes of Stories",
#         "productType": "Art Print",
#         "tags": ["storybeats", "11x14", "print"]
#         # You can add collection publishing etc. later
#     }

#     product_metafields = {
#         "story.title": "The Great Gatsby",
#         "story.protagonist": "Jay Gatsby",
#         "story.slug": "the-great-gatsby-jay-gatsby",
#         "story.year": 1925,
#         "story.type": "Literature",
#         "story.manual_collections": ["Literature", "Gallery Walls"],

#         "shape.symbolic_representation": "rise-fall-rise",
#         "shape.archetype": "Tragic Hero",

#         "literature.author": "F. Scott Fitzgerald",
#         "literature.genres": ["Novel", "Modernist"],
#         "literature.themes": ["American Dream", "Wealth", "Love"],
#         "literature.settings": ["Long Island", "New York City"],
#         "literature.countries": ["United States"],
#         "literature.series_or_universe": [],
#         "literature.awards": [],
#         "literature.primary_isbns": ["9780743273565"],
#     }

#     create_product_and_set_metafields(product_input, product_metafields)
