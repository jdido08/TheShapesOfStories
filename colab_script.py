
# ==============================================================================
#           THE SHAPES OF STORIES - GOOGLE COLAB SCRIPT
# ==============================================================================
#
# This script was automatically generated by 'combine_for_colab.py'.
# It contains all project code in a single file and has had local
# import statements (e.g., 'from llm import...') automatically removed.
#
# ------------------------------------------------------------------------------


# ==============================================================================
#  CONTENTS FROM: llm.py
# ==============================================================================

import os
import json
import yaml
import tiktoken
# from langchain_community.llms import OpenAI
# from langchain_community.chat_models import ChatOpenAI
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_google_genai import ChatGoogleGenerativeAI, HarmCategory, HarmBlockThreshold
import re
from langchain_groq import ChatGroq

#Models:
# openai - https://platform.openai.com/docs/models
# anthropic - https://docs.anthropic.com/en/docs/about-claude/models 
#   - claude-3-5-sonnet-latest





def load_config(config_path):
    with open(config_path, "r") as stream:
        return yaml.safe_load(stream)

def get_llm(provider: str, model: str, config: dict, max_tokens: int = 1024):
    provider = provider.lower()
    if provider == "openai":
        # Import the chat model from the community chat models module.
        #from langchain_community.chat_models import ChatOpenAI
        from langchain_openai import ChatOpenAI
        openai_api_key = config.get("openai_key")
        if not openai_api_key:
            raise ValueError("openai_key_vonnegutgraphs must be specified in the config")
        # Pass the API key as a parameter.
        llm = ChatOpenAI(model_name=model, 
                        openai_api_key=openai_api_key,
                        max_tokens=max_tokens)
    elif provider == "anthropic":
        from langchain_anthropic import ChatAnthropic
        anthropic_api_key = config.get("anthropic_key")
        if not anthropic_api_key:
            raise ValueError("anthropic_key must be specified in the config")
        llm = ChatAnthropic(model=model, 
                            anthropic_api_key=anthropic_api_key,
                            max_tokens=max_tokens)
    elif provider in {"google", "gemini"}:
        # Google Gemini (via Google Generative AI)
        # models gemini-2.5-pro-preview-03-25
        google_api_key = config.get("google_gemini_key")  # or fall back to env var
        if not google_api_key and not os.getenv("GOOGLE_API_KEY"):
            raise ValueError("google_api_key must be specified in the config or env")

        # ChatGoogleGenerativeAI uses `max_output_tokens` rather than `max_tokens`
        llm = ChatGoogleGenerativeAI(
          model=model,                    # e.g. "gemini-pro", "gemini-1.5-flash-latest"
            google_api_key=google_api_key,  # optional if env var is set
            max_output_tokens=max_tokens,
            safety_settings={
                HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_NONE,
                HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_NONE,
                HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_NONE,
                HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_NONE,
            }
            #  model_kwargs={
            # "response_format": {"type": "json_object"} # force raw JSON
            # }
        )   # keeps your current signature unchanged        )
    elif provider == "groq":
        
        groq_api_key = config.get("groq_key")
        if not groq_api_key:
            # You can also allow it to be set as an environment variable
            # groq_api_key = os.getenv("GROQ_API_KEY")
            # if not groq_api_key:
            raise ValueError("groq_api_key must be specified in the config")
        llm = ChatGroq(model_name=model, # Groq uses model_name
                       groq_api_key=groq_api_key,
                       max_tokens=max_tokens) # ChatGroq uses max_tokens
        
    else:
        raise ValueError(f"Unsupported provider: {provider}")
    return llm


def extract_json(text: str) -> str:
    """
    Remove markdown code fences (e.g. ```json ... ```) from the text.
    """
    # This regex will remove the ```json and ``` markers.
    # It assumes that the JSON is enclosed in them.
    pattern = r"```(?:json)?\s*(.*?)\s*```"
    match = re.search(pattern, text, re.DOTALL)
    if match:
        return match.group(1).strip()
    return text.strip()

# ==============================================================================
#  CONTENTS FROM: story_data.py
# ==============================================================================

from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
import yaml
import tiktoken
import json 
import os 

def analyze_story(config_path, author_name, story_title, protagonist, story_summary, llm_provider, llm_model):
    

    # The user_message includes placeholders that will be replaced by the function arguments
    prompt_template = """You are a world-class literary scholar and expert in story analysis. Your task is to analyze a story through the emotional journey of {protagonist}. Please carefully read and analyze the following story summary:

<author_name>
{author_name}
</author_name>

<story_title>
{story_title}
</story_title>

<protagonist>
{protagonist}
</protagonist>

<story_summary>
{story_summary}
</story_summary>

## Framework Overview:
1. Story Timeline: The narrative is viewed on a scale from 0 to 100, representing the percentage of progress through the story.
2. Story Components: The story is segmented into components defined by {protagonist}'s emotional journey.
3. Continuity: Each story component starts where the previous one ended, ensuring a seamless emotional journey.
4. Emotional Arcs: {protagonist}'s emotional journey throughout each story component can vary in a range from euphoric (+10) to depressed (-10), based on their direct experiences and reactions to events.


## Emotional Arcs
### Types of Emotional Arcs:
1. Increase: The protagonist's emotional state improves by the end of the arc.
2. Decrease: The protagonist's emotional state worsens by the end of the arc.
3. Flat: The protagonist's emotional state remains unchanged by the end of the arc.

### Specific Emotional Arc Patterns:
1. Step-by-Step Increase/Decrease: Emotions change in distinct, noticeable stages
   Example: A character moving from fear (-5) to uncertainty (-2) to hope (+2) to joy (+6)
2. Linear Increase/Decrease: Consistent, steady change in emotional state
   Example: A character's growing dread as they approach danger, declining steadily from +3 to -4
3. Gradual-to-Rapid Increase/Decrease: Change starts slowly, then accelerates
   Example: A slow build of suspicion that suddenly turns to shocking realization
4. Rapid-to-Gradual Increase/Decrease: Change starts quickly, then slows down
   Example: An immediate burst of joy that settles into content satisfaction
5. Straight Increase/Decrease: Sudden, dramatic change in emotions
   Example: An unexpected tragedy causing immediate shift from +5 to -8
6. S-Curve Increase/Decrease: Change follows an 'S' shape (slow-fast-slow)
   Example: Gradually accepting good news, rapid excitement, then settling into happiness
7. Linear Flat: No change in emotions
   Example: Maintaining determined focus throughout a challenging task

## Analysis Guidelines

### Analysis Steps:
1. Understand {protagonist}'s starting position in the story.
   - Identify their initial circumstances and relationships
   - Look for early indicators of their emotional state
   - Note their primary motivations and desires
2. Segment the story into components based on major changes in {protagonist}'s emotions.
   - The number of components should be determined by the natural transitions in their emotional state
   - Most stories will naturally fall into 4-8 components, though shorter or longer stories may fall outside this range
   - Each significant change in their emotional state should mark the start of a new component
   - As a general guideline, major emotional changes typically involve shifts of at least 3-4 points on the -10 to +10 scale
   - Components can vary in length based on the pace of emotional change
   - Avoid over-segmentation: only create new components for meaningful shifts in emotional state
3. Identify the emotional scores of each story component.
   - Scores must be whole numbers between -10 and +10 that reflect {protagonist}'s emotional state as evidenced in the story summary
   - Score changes must match the selected arc type
4. For each story component:
   - Identify the portion of the story summary that shows {protagonist}'s experience
   - Focus on events and details that reveal their emotional state
   - Note their actions, reactions, and key interactions
   - Use these details to write a description that centers on their journey
5. Identify the emotional arcs which connect story components.

After your analysis, provide the final output in the following JSON format:

{{{{
    "title": "Story Title",
    "protagonist": "Protagonist",
    "story_components": [
        {{{{
            "end_time": 0,
            "description": "#N/A",
            "end_emotional_score": initial_score,
            "arc": "#N/A"
        }}}},
        {{{{
            "end_time": percentage,
            "description": "Detailed description of events in this component",
            "end_emotional_score": score,
            "arc": "Arc Type"
        }}}},
    ]
}}}}

### Story Component Description Guidelines:
- Each description must be derived directly from the provided story summary
- Center the description on {protagonist}'s experience and perspective
- Describe events primarily in terms of their impact on {protagonist}
- Include their actions, reactions, and emotional responses
- Detail settings as they relate to their experience
- Include other characters mainly through their interaction with or impact on {protagonist}
- Quote or closely paraphrase passages that reveal their emotional state
- Include sensory details that contribute to understanding their experience

### Initial Emotional Score Guidelines:
- Carefully examine how {protagonist} is first presented in the story
- Look for descriptive words indicating their initial emotional state
- Consider their starting circumstances and relationships

## Important Notes:
- The first component always has an end_time of 0, no description, and no arc.
- Ensure that end_emotional_scores are consistent with the arc types (e.g., an "Increase" arc should have a higher end_emotional_score than the previous component).
- Emotional scores must be whole numbers between -10 and +10.
- Adjacent components should not have the same emotional score unless using Linear Flat arc.
- End times must be in ascending order and the final component must end at 100.
- Each arc type must match the emotional change described:
  * Increase arcs must show higher end scores than start scores
  * Decrease arcs must show lower end scores than start scores
  * Flat arcs must maintain the same score
- Double-check your analysis for accuracy and internal consistency before providing the final JSON output.

Please proceed with your analysis and provide the JSON output. ONLY respond with the JSON and nothing else.

____________________

EXAMPLE:

<example>
<author_name>
Charles Perrault
</author_name>
<story_title>
Cinderella at the Ball
</story_title>
<protagonist>
Cinderella
</protagonist>
<story_summary>
Heartbroken and exhausted, Cinderella toils endlessly in her own home after her father’s death leaves her at the mercy of her cruel stepmother and spiteful stepsisters. Forced to cook, clean, and tend to every chore while enduring their constant insults, Cinderella clings to a quiet hope for a kinder future, though she often feels lonely and powerless. One day, an announcement arrives that the royal family is hosting a grand ball to find a bride for the Prince. Eager for a chance at happiness, Cinderella timidly asks if she may attend. Her stepmother and stepsisters mock her wish and forbid it, leaving her devastated. Even so, Cinderella manages to gather scraps of optimism, trying to sew a suitable dress from her late mother’s belongings—only for her stepsisters to shred it in a fit of jealousy moments before the ball. Crushed by this cruel betrayal, she flees to the garden, overwhelmed by despair. It is there that her Fairy Godmother appears, transforming Cinderella’s tattered clothes into a resplendent gown and conjuring a gleaming carriage from a humble pumpkin. As Cinderella’s hopes rise, the Fairy Godmother warns her that the magic will end at midnight. At the grand royal ball, the Prince is immediately enchanted by her gentle grace and luminous presence. For the first time, Cinderella basks in admiration instead of scorn, feeling her spirits soar with each dance and conversation. However, as the clock strikes midnight, she is forced to flee the palace. In her panic to escape before the spell breaks, she loses one of her delicate glass slippers on the palace steps. Despite her sudden disappearance, the Prince is determined to find this mysterious young woman, traveling throughout the kingdom with the slipper in hand. When his search brings him to Cinderella’s home, her stepsisters deride the idea that she could be the one who captured the Prince’s heart. Yet, as soon as Cinderella tries on the slipper, it fits perfectly. Freed at last from servitude, she marries the Prince, and her enduring kindness and patience are joyously rewarded.
</story_summary>
<ideal_output>
{{{{
    "title": "Cinderella at the Ball",
    "protagonist": "Cinderella",
    "story_components": [
        {{{{
            "end_time": 0,
            "description": "#N/A",
            "end_emotional_score": -5,
            "arc": "#N/A"
        }}}},
        {{{{
            "end_time": 30,
            "description": "Cinderella weeps alone in the garden, heartbroken after her stepfamily mocks her desires and denies her chance to attend the ball. Her despair turns to wonder when her Fairy Godmother appears, transforming her circumstances through magical gifts: her pumpkin becomes a splendid carriage, mice become horses, and she receives a resplendent gown with glass slippers. Despite her rising hopes, she must bear the weight of the midnight deadline.",
            "end_emotional_score": 2,
            "arc": "Step-by-Step Increase"
        }}}},
        {{{{
            "end_time": 60,
            "description": "Cinderella experiences a profound transformation as she arrives at the grand ball. Her kindness and radiant beauty draw the Prince's attention, and she finds herself, for the first time, being treated with admiration and respect. As she dances with the Prince throughout the evening, each moment fills her with increasing joy and wonder, allowing her to momentarily forget her life of servitude.",
            "end_emotional_score": 8,
            "arc": "Gradual-to-Rapid Increase"
        }}}},
        {{{{
            "end_time": 75,
            "description": "Cinderella's magical evening shatters as the clock strikes midnight. Panic overtakes her as she flees the palace, losing a glass slipper in her desperate rush to escape. Her brief taste of happiness ends abruptly as she races to prevent the revelation of her true identity, watching her transformed world revert to its ordinary state.",
            "end_emotional_score": -3,
            "arc": "Straight Decrease"
        }}}},
        {{{{
            "end_time": 100,
            "description": "Cinderella's hopes revive when the Prince begins searching for her with the glass slipper. Her moment of triumph arrives when she steps forward in her home to try on the slipper, and it fits perfectly. Her patient endurance is finally rewarded as she marries the Prince, rising from her life of servitude to find happiness, maintaining her gracious nature by forgiving her stepfamily.",
            "end_emotional_score": 10,
            "arc": "Gradual-to-Rapid Increase"
        }}}}
    ]
}}}}
</ideal_output>
</example>

Note About Example Output:
The descriptions in the example output demonstrate the minimum expected level of detail for story components. Each description should:
- Center on the protagonist's experience and emotional journey
- Include concrete details that reveal the protagonist's state of mind
- Use language that reflects the protagonist's perspective
- Capture interactions primarily through their impact on the protagonist

"""
    
    prompt = PromptTemplate(
        input_variables=["author_name", "story_title", "protagonist", "story_summary"],  # Define the expected inputs
        template=prompt_template
    )


    config = load_config(config_path=config_path)
    llm = get_llm(llm_provider, llm_model, config, max_tokens=8192)

    # Instead of building an LLMChain, use the pipe operator:
    runnable = prompt | llm

    try:
        output = runnable.invoke({
            "author_name": author_name,
            "story_title": story_title,
            "protagonist": protagonist,
            "story_summary": story_summary,
        })
        # If output is a AIMessage, its `response_metadata` might have info
        if hasattr(output, "response_metadata"):
            print("LLM Response Metadata:", output.response_metadata)

    except Exception as e:
        print(f"Error during LLM call: {e}")
        if hasattr(e, 'response') and hasattr(e.response, 'prompt_feedback'): # Example for some libraries
            print("Prompt Feedback:", e.response.prompt_feedback)

    # If the output is an object with a 'content' attribute, extract it.
    if hasattr(output, "content"):
        output_text = output.content
    else:
        output_text = output

    #attempt to extact json (if needed)
    output_text = extract_json(output_text)


    return output_text



def validate_story_arcs(data): #data should be json object
    
    # Initialize an empty list to store validation results
    validation_results = []
    
    # Previous emotional score for comparison; start with the first component
    title = data['title']
    prev_score = data['story_components'][0]['end_emotional_score']
    
    # Iterate through story components, starting from the second one
    for component in data['story_components'][1:]:
        current_score = component['end_emotional_score']
        arc = component['arc']
        end_time = component['end_time']
        expected_change = None
        
        # Determine expected change based on the arc description
        if "Increase" in arc:
            expected_change = "increase"
        elif "Decrease" in arc:
            expected_change = "decrease"
        elif "Flat" in arc:
            expected_change = "flat"
        
        # Determine actual change
        actual_change = None
        if current_score > prev_score:
            actual_change = "increase"
        elif current_score < prev_score:
            actual_change = "decrease"
        else:
            actual_change = "flat"
        
        # Compare expected change with actual change
        matches_description = expected_change == actual_change
        
        if(matches_description == False):
            error_string = f'ERROR: In {title} at end_time: {end_time} arc specified was: {expected_change} but actual score change was: {actual_change}'
            print(error_string)
            return "invalid"
        
        # Update previous score for the next iteration
        prev_score = current_score
    
    return "valid"


def num_tokens_from_string(string: str, model: str) -> int:
    """Returns the number of tokens in a text string."""
    #encoding = tiktoken.get_encoding(encoding_name)
    encoding = tiktoken.encoding_for_model(model)
    num_tokens = len(encoding.encode(string))
    return num_tokens


def create_story_data(config_path = "", summary_dir = "", summary_file="", author="", year="", protagonist="", output_path="", 
                      llm_provider="anthropic", llm_model="claude-3-5-sonnet-20241022"):


    summary_file_path = os.path.join(summary_dir, summary_file)
    with open(summary_file_path, 'r', encoding='utf-8') as file:
        story_data = json.load(file)
    
    
    story_title = story_data['title']
    print("Creating story data for ", story_title)

    if author == "":
        author = story_data['openlib']['author_name'][0]
    
    if year == "":
        year = story_data['openlib']['publishing']['first_publish_year']

    # List is in priority order
    summary_sources = [
        'sparknotes', 'cliffnotes', 'bookwolf', 'gradesaver', 
        'novelguide', 'pinkmonkey', 'shmoop', 'thebestnotes', 'wiki', 'other'
    ]

    story_summary = ""
    story_summary_source = ""

    #use longest summary proxy for most complete
    for summary_source in summary_sources:
        if summary_source in story_data:
            summary_text = story_data[summary_source].get('summary', '')
            if summary_text and len(summary_text) > len(story_summary):
                story_summary = summary_text
                story_summary_source = summary_source
    
    #print(story_summary_source)
    story_plot_data = analyze_story(config_path=config_path, author_name=author, story_title=story_title, protagonist=protagonist, story_summary=story_summary,
                                    llm_provider=llm_provider,llm_model=llm_model)
    story_plot_data = json.loads(story_plot_data)
    story_validity = validate_story_arcs(story_plot_data)
    story_plot_data["type"] = "book"
    story_plot_data["author"] = author
    story_plot_data["year"] = year
    story_plot_data['summary'] = story_summary
    story_plot_data['story_summary_source'] = story_summary_source
    story_plot_data['shape_validity'] = story_validity
    story_plot_data['story_data_llm'] = llm_model

    if story_plot_data['protagonist'] != protagonist:
        print("LLM designated protagonist as: ", story_plot_data['protagonist'], " but I specified protagonist as: ", protagonist)
        print("PLEASE RESOLVE")
        raise ValueError
   

    for component in story_plot_data["story_components"]:
        component['modified_end_time'] = component['end_time']
        component['modified_end_emotional_score'] = component['end_emotional_score']
    
    output_path = output_path
    title = story_plot_data['title'].lower().replace(' ', '-') + "_" + story_plot_data['protagonist'].lower().replace(' ', '-')
    output_path = os.path.join(output_path, f"{title}.json")
    with open(output_path, 'w') as json_file:
        json.dump(story_plot_data, json_file, indent=4)

    return story_plot_data, output_path










# ==============================================================================
#  CONTENTS FROM: story_style.py
# ==============================================================================

from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
import yaml
import tiktoken
import json 
import os 

def get_story_style(story_title, author, protagonist, llm_provider, llm_model):


    prompt_template = """
# Story Style Guide Generator

You are a design specialist combining expertise in literary analysis and visual design. Your task is to create a cohesive visual style for a story visualization that captures the essence of the narrative while maintaining aesthetic and technical excellence.

Input:
- Story Title: {story_title}
- Author: {author}
- Protagonist: {protagonist}

Analysis Framework:
1. Story Elements
   - Historical visual traditions e.g. iconic cover designs and established print design elements that audiences would recognize (if applicable)
   - Setting (time period, location, social context)
   - Dominant mood and atmosphere (consider the overall emotional landscape of the work and protagonist)
   - Core themes and the protagonist's journey
   - Key symbols and motifs

2. Design Requirements
   Colors must:
   - Work in both digital and print formats
   - Maintain impact under various lighting
   - Meet accessibility standards (4.5:1 minimum contrast)
   - Connect meaningfully to story elements
   
   Typography must:
   - Reflect story's period and tone
   - Maintain legibility in curved layouts
   - Include appropriate weight variations
   - Be commercially licensable

Process:
1. Analyze story elements
2. Develop color palette considering:
   - Story themes and setting
   - Symbolic significance
   - Technical requirements
3. Select typography that:
   - Captures narrative tone
   - Functions technically
   - Bridges historical and modern needs
4. Output ONLY JSON in the following exact structure and nothing else
{{  
  "design_rationale":"",
  "background_color": "",  
  "font_color": "",       
  "border_color": "",     
  "font": ""            
}}

Example #1:
Story Title: Romeo and Juliet
Author: William Shakespeare
Protagonist: Juliet

Output:
{{  
  "design_rationale":"The passionate romance, tragic fate, and themes of youth and nobility are reflected in rich burgundy tones with gold accents, while the elegant serif typeface echoes both Renaissance Italy and timeless romance.",
  "background_color": "#8C1C13",
  "font_color": "#F4D03F",
  "border_color": "#590D0D",
  "font": "Cormorant Garamond"
}}

Example #2:
Story Title: The Iliad
Author: Homer
Protagonist: Achilles

Output:
{{  
  "design_rationale": "Drawing from ancient Greek aesthetics and the epic's themes of divine warfare and mortal pride, the design pairs a deep bronze background with marble-white text. The classical typeface Trajan Pro evokes both heroic Roman inscriptions and timeless gravitas, while ensuring clarity in the curved narrative of warfare and honor.",
  "background_color": "#704214",
  "font_color": "#F5F5F5",
  "border_color": "#463A2C",
  "font": "Trajan Pro"
}}
"""


    prompt = PromptTemplate(
        input_variables=["story_title", "author", "protagonist"],  # Define the expected inputs
        template=prompt_template
    )


    config = load_config()
    llm = get_llm(llm_provider, llm_model, config, max_tokens=1000)

    # Instead of building an LLMChain, use the pipe operator:
    runnable = prompt | llm

    # Then invoke with the required inputs:
    output = runnable.invoke({
        "story_title": story_title,
        "author": author,
        "protagonist": protagonist
    })

    #print(output)

    # If the output is an object with a 'content' attribute, extract it.
    if hasattr(output, "content"):
        output_text = output.content
    else:
        output_text = output

    #attempt to extact json (if needed)
    story_style = extract_json(output_text)
    print(story_style)
    return story_style


    # story_style = json.loads(output_text)
    # background_color = story_style['background_color'],
    # font_color = story_style['font_color']
    # border_color = story_style['border_color']
    # font = story_style['font']


# ==============================================================================
#  CONTENTS FROM: poster_layout_templates.py
# ==============================================================================

# poster_layout_templates.py

poster_layout_templates = {
    # --- 2 Stories ---
    "stories2_horizontal_split": {
        "description": "Two stories side-by-side, splitting the poster horizontally.",
        "num_stories": 2,
        "base_rows": 1,
        "base_cols": 2,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 0},
            {'base_row': 0, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 1},
        ]
    },
    "stories2_vertical_split": {
        "description": "Two stories stacked, splitting the poster vertically.",
        "num_stories": 2,
        "base_rows": 2,
        "base_cols": 1,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 0},
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 1},
        ]
    },

    # --- 3 Stories ---
    "stories3_row": {
        "description": "Three stories in a single row.",
        "num_stories": 3,
        "base_rows": 1,
        "base_cols": 3,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 0},
            {'base_row': 0, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 1},
            {'base_row': 0, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 2},
        ]
    },
    "stories3_column": {
        "description": "Three stories in a single column.",
        "num_stories": 3,
        "base_rows": 3,
        "base_cols": 1,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 0},
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 1},
            {'base_row': 2, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 2},
        ]
    },
    "stories3_hero_left_two_stacked_right": {
        "description": "One large story on the left, two smaller stories stacked on the right.",
        "num_stories": 3,
        "base_rows": 2,
        "base_cols": 2,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 2, 'col_span': 1, 'content_index': 0}, # Hero Left
            {'base_row': 0, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 1}, # Top Right
            {'base_row': 1, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 2}, # Bottom Right
        ]
    },
    "stories3_hero_top_two_bottom": {
        "description": "One large story on the top, two smaller stories side-by-side below.",
        "num_stories": 3,
        "base_rows": 2,
        "base_cols": 2,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 2, 'content_index': 0}, # Hero Top
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 1}, # Bottom Left
            {'base_row': 1, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 2}, # Bottom Right
        ]
    },

    # --- 4 Stories ---
     "stories4_4x1_grid": {
        "description": "Four stories in a 4x1 grid.",
        "num_stories": 4,
        "base_rows": 4,
        "base_cols": 1,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 0},
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 1},
            {'base_row': 2, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 2},
            {'base_row': 3, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 3},
        ]
    },
    "stories4_2x2_grid": {
        "description": "Four stories in a 2x2 grid.",
        "num_stories": 4,
        "base_rows": 2,
        "base_cols": 2,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 0},
            {'base_row': 0, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 1},
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 2},
            {'base_row': 1, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 3},
        ]
    },
    "stories4_hero_left_three_stacked_right": {
        "description": "One tall story on the left, three smaller stories stacked on the right.",
        "num_stories": 4,
        "base_rows": 3,
        "base_cols": 2,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 3, 'col_span': 1, 'content_index': 0}, # Hero Left
            {'base_row': 0, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 1}, # Top Right
            {'base_row': 1, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 2}, # Mid Right
            {'base_row': 2, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 3}, # Bottom Right
        ]
    },
     "stories4_hero_top_three_bottom_row": {
        "description": "One wide story on top, three smaller stories in a row below.",
        "num_stories": 4,
        "base_rows": 2,
        "base_cols": 3,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 3, 'content_index': 0}, # Hero Top
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 1}, # Bottom Left
            {'base_row': 1, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 2}, # Bottom Mid
            {'base_row': 1, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 3}, # Bottom Right
        ]
    },

    # --- 5 Stories ---
    "stories5_pinwheel_center_hero": {
        "description": "One story in the center, four stories around it (pinwheel style). All cells are 1x1 in a 3x3 base grid.",
        "num_stories": 5,
        "base_rows": 3,
        "base_cols": 3,
        "grid_template": [
            {'base_row': 1, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 0}, # Center
            {'base_row': 0, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 1}, # Top Middle
            {'base_row': 2, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 2}, # Bottom Middle
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 3}, # Middle Left
            {'base_row': 1, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 4}, # Middle Right
        ]
    },
    "stories5_hero_top_left_L_shape": {
        "description": "One large 2x2 story top-left, with four 1x1 stories forming an L-shape around it (bottom and right).",
        "num_stories": 5,
        "base_rows": 3,
        "base_cols": 3,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 2, 'col_span': 2, 'content_index': 0}, # Hero (2x2)
            {'base_row': 0, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 1}, # Top Right
            {'base_row': 1, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 2}, # Mid Right
            {'base_row': 2, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 3}, # Bottom Left
            {'base_row': 2, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 4}, # Bottom Mid
        ]
    },
    "stories5_two_top_three_bottom": {
        "description": "Two wider stories in the top row, three narrower stories in the bottom row. Uses a 2x6 base grid.",
        "num_stories": 5,
        "base_rows": 2,
        "base_cols": 6,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 3, 'content_index': 0}, # Top Left (half width)
            {'base_row': 0, 'base_col': 3, 'row_span': 1, 'col_span': 3, 'content_index': 1}, # Top Right (half width)
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 2, 'content_index': 2}, # Bottom Left (third width)
            {'base_row': 1, 'base_col': 2, 'row_span': 1, 'col_span': 2, 'content_index': 3}, # Bottom Mid (third width)
            {'base_row': 1, 'base_col': 4, 'row_span': 1, 'col_span': 2, 'content_index': 4}, # Bottom Right (third width)
        ]
    },

    # --- 6 Stories ---
    "stories6_2x3_grid": {
        "description": "Six stories in a 2x3 grid (2 rows, 3 columns).",
        "num_stories": 6,
        "base_rows": 2,
        "base_cols": 3,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 0},
            {'base_row': 0, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 1},
            {'base_row': 0, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 2},
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 3},
            {'base_row': 1, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 4},
            {'base_row': 1, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 5},
        ]
    },
    "stories6_3x2_grid": {
        "description": "Six stories in a 3x2 grid (3 rows, 2 columns).",
        "num_stories": 6,
        "base_rows": 3,
        "base_cols": 2,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 0},
            {'base_row': 0, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 1},
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 2},
            {'base_row': 1, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 3},
            {'base_row': 2, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 4},
            {'base_row': 2, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 5},
        ]
    },
    "stories6_two_wide_left_four_regular_right": {
        "description": "Two wide stories stacked on the left, four regular-width stories in a 2x2 grid on the right. Uses a 2x4 base grid.",
        "num_stories": 6,
        "base_rows": 2,
        "base_cols": 4,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 2, 'content_index': 0}, # Wide Top Left
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 2, 'content_index': 1}, # Wide Bottom Left
            {'base_row': 0, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 2}, # Regular TR1
            {'base_row': 0, 'base_col': 3, 'row_span': 1, 'col_span': 1, 'content_index': 3}, # Regular TR2
            {'base_row': 1, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 4}, # Regular BR1
            {'base_row': 1, 'base_col': 3, 'row_span': 1, 'col_span': 1, 'content_index': 5}, # Regular BR2
        ]
    },

    # --- 7 Stories ---
    "stories7_complex_hero_center_tall": {
        "description": "Three 1x1 stories on top row, three tall (2-row span) stories in middle, one wide (3-col span) story on bottom. Uses a 4x3 base grid.",
        "num_stories": 7,
        "base_rows": 4,
        "base_cols": 3,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 0}, # Top Left
            {'base_row': 0, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 1}, # Top Middle
            {'base_row': 0, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 2}, # Top Right
            {'base_row': 1, 'base_col': 0, 'row_span': 2, 'col_span': 1, 'content_index': 3}, # Left Mid Tall
            {'base_row': 1, 'base_col': 1, 'row_span': 2, 'col_span': 1, 'content_index': 4}, # Center Hero Tall
            {'base_row': 1, 'base_col': 2, 'row_span': 2, 'col_span': 1, 'content_index': 5}, # Right Mid Tall
            {'base_row': 3, 'base_col': 0, 'row_span': 1, 'col_span': 3, 'content_index': 6}, # Bottom Wide
        ]
    },

    # --- 8 Stories ---
    "stories8_2x4_grid": {
        "description": "Eight stories in a 2x4 grid (2 rows, 4 columns).",
        "num_stories": 8,
        "base_rows": 2,
        "base_cols": 4,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 0},
            {'base_row': 0, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 1},
            {'base_row': 0, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 2},
            {'base_row': 0, 'base_col': 3, 'row_span': 1, 'col_span': 1, 'content_index': 3},
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 4},
            {'base_row': 1, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 5},
            {'base_row': 1, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 6},
            {'base_row': 1, 'base_col': 3, 'row_span': 1, 'col_span': 1, 'content_index': 7},
        ]
    },
    "stories8_4x2_grid": {
        "description": "Eight stories in a 4x2 grid (4 rows, 2 columns).",
        "num_stories": 8,
        "base_rows": 4,
        "base_cols": 2,
        "grid_template": [
            {'base_row': i // 2, 'base_col': i % 2, 'row_span': 1, 'col_span': 1, 'content_index': i} for i in range(8) # Corrected for 4x2
            # Explicitly:
            # Row 0
            #{'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 0},
            #{'base_row': 0, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 1},
            # Row 1
            #{'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 2},
            #{'base_row': 1, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 3},
            # Row 2
            #{'base_row': 2, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 4},
            #{'base_row': 2, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 5},
            # Row 3
            #{'base_row': 3, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 6},
            #{'base_row': 3, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 7},
        ]
    },
    "stories8_2_4_2_rows": {
        "description": "Eight stories: 2 wide on top row, 4 regular in middle row, 2 wide on bottom row. Uses a 3x4 base grid.",
        "num_stories": 8,
        "base_rows": 3,
        "base_cols": 4,
        "grid_template": [
            {'base_row': 0, 'base_col': 0, 'row_span': 1, 'col_span': 2, 'content_index': 0}, # Top Left Wide
            {'base_row': 0, 'base_col': 2, 'row_span': 1, 'col_span': 2, 'content_index': 1}, # Top Right Wide
            {'base_row': 1, 'base_col': 0, 'row_span': 1, 'col_span': 1, 'content_index': 2}, # Mid R1C1
            {'base_row': 1, 'base_col': 1, 'row_span': 1, 'col_span': 1, 'content_index': 3}, # Mid R1C2
            {'base_row': 1, 'base_col': 2, 'row_span': 1, 'col_span': 1, 'content_index': 4}, # Mid R1C3
            {'base_row': 1, 'base_col': 3, 'row_span': 1, 'col_span': 1, 'content_index': 5}, # Mid R1C4
            {'base_row': 2, 'base_col': 0, 'row_span': 1, 'col_span': 2, 'content_index': 6}, # Bot Left Wide
            {'base_row': 2, 'base_col': 2, 'row_span': 1, 'col_span': 2, 'content_index': 7}, # Bot Right Wide
        ]
    },

    # --- 9 Stories ---
    "stories9_3x3_grid": {
        "description": "Nine stories in a 3x3 grid.",
        "num_stories": 9,
        "base_rows": 3,
        "base_cols": 3,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 3 + c}
            for r in range(3) for c in range(3)
        ]
    },

    # --- 12 Stories ---
    "stories12_3x4_grid": {
        "description": "Twelve stories in a 3x4 grid (3 rows, 4 columns).",
        "num_stories": 12,
        "base_rows": 3,
        "base_cols": 4,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 4 + c}
            for r in range(3) for c in range(4)
        ]
    },
    "stories12_4x3_grid": {
        "description": "Twelve stories in a 4x3 grid (4 rows, 3 columns).",
        "num_stories": 12,
        "base_rows": 4,
        "base_cols": 3,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 3 + c}
            for r in range(4) for c in range(3)
        ]
    },
        # --- 15 Stories ---
    "stories15_3x5_grid" : {
        "description": "Fifteen stories in a 3x5 grid (3 rows, 5 columns).",
        "num_stories": 15,
        "base_rows": 3,
        "base_cols": 5,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 5 + c}
            for r in range(3) for c in range(5)
        ]
    },
    "stories15_5x3_grid" : {
        "description": "Fifteen stories in a 5x3 grid (5 rows, 3 columns).",
        "num_stories": 15,
        "base_rows": 5,
        "base_cols": 3,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 3 + c}
            for r in range(5) for c in range(3)
        ]
    },

    # --- 20 Stories ---
    "stories20_4x5_grid" : {
        "description": "Twenty stories in a 4x5 grid (4 rows, 5 columns).",
        "num_stories": 20,
        "base_rows": 4,
        "base_cols": 5,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 5 + c}
            for r in range(4) for c in range(5)
        ]
    },
    "stories20_5x4_grid" : {
        "description": "Twenty stories in a 5x4 grid (5 rows, 4 columns).",
        "num_stories": 20,
        "base_rows": 5,
        "base_cols": 4,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 4 + c}
            for r in range(5) for c in range(4)
        ]
    },

    # --- 25 Stories ---
    "stories25_5x5_grid" : {
        "description": "Twenty-five stories in a 5x5 grid.",
        "num_stories": 25,
        "base_rows": 5,
        "base_cols": 5,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 5 + c}
            for r in range(5) for c in range(5)
        ]
    },

    # --- 50 Stories ---
    "stories50_5x10_grid" : {
        "description": "Fifty stories in a 5x10 grid (5 rows, 10 columns). Good for landscape posters.",
        "num_stories": 50,
        "base_rows": 5,
        "base_cols": 10,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 10 + c}
            for r in range(5) for c in range(10)
        ]
    },
    "stories50_10x5_grid" : {
        "description": "Fifty stories in a 10x5 grid (10 rows, 5 columns). Good for portrait posters.",
        "num_stories": 50,
        "base_rows": 10,
        "base_cols": 5,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 5 + c}
            for r in range(10) for c in range(5)
        ]
    },

    # --- 100 Stories ---
    "stories100_10x10_grid" : {
        "description": "One hundred stories in a 10x10 grid. Most balanced for large counts.",
        "num_stories": 100,
        "base_rows": 10,
        "base_cols": 10,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 10 + c}
            for r in range(10) for c in range(10)
        ]
    },
    "stories100_5x20_grid" : {
        "description": "One hundred stories in a 5x20 grid (5 rows, 20 columns). Very wide, for panoramic landscape posters.",
        "num_stories": 100,
        "base_rows": 5,
        "base_cols": 20,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 20 + c}
            for r in range(5) for c in range(20)
        ]
    },
    "stories100_20x5_grid" : {
        "description": "One hundred stories in a 20x5 grid (20 rows, 5 columns). Very tall, for panoramic portrait posters.",
        "num_stories": 100,
        "base_rows": 20,
        "base_cols": 5,
        "grid_template": [
            {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 5 + c}
            for r in range(20) for c in range(5)
        ]
    },
}

# Correcting the list comprehension for stories8_4x2_grid
poster_layout_templates["stories8_4x2_grid"]["grid_template"] = [
    {'base_row': r, 'base_col': c, 'row_span': 1, 'col_span': 1, 'content_index': r * 2 + c}
    for r in range(4) for c in range(2)
]


if __name__ == '__main__':
    # This is an example of how you might use these templates with your existing functions.
    # You would need to have your poster_creator.py functions (create_layout_preview,
    # calculate_cell_content_size, create_poster) available in the same scope or imported.

    # --- How to use a template ---

    # 1. Choose a template
    chosen_template_name = "stories5_hero_top_left_L_shape"
    template_details = poster_layout_templates[chosen_template_name]

    print(f"Using template: {chosen_template_name} - {template_details['description']}")
    print(f"  Expected number of stories: {template_details['num_stories']}")
    print(f"  Base grid: {template_details['base_rows']} rows x {template_details['base_cols']} cols")

    # 2. Define poster parameters (these are examples)
    poster_width_inches = 18
    poster_height_inches = 24
    poster_dpi = 72 # Lower for preview, 300 for print
    poster_margin_inches = 1.0
    poster_spacing_inches = 0.5
    output_folder = "./layout_previews/" # Make sure this folder exists
    import os
    os.makedirs(output_folder, exist_ok=True)

    # 3. Generate a layout preview (if you have create_layout_preview function)
    # Assuming create_layout_preview is defined as in your provided code
    # from poster_creator import create_layout_preview, calculate_cell_content_size # If in separate file

    # Example: Call create_layout_preview
    # create_layout_preview(
    #     poster_width_in=poster_width_inches,
    #     poster_height_in=poster_height_inches,
    #     output_path=os.path.join(output_folder, f"preview_{chosen_template_name}.png"),
    #     base_rows=template_details['base_rows'],
    #     base_cols=template_details['base_cols'],
    #     grid_template=template_details['grid_template'],
    #     dpi=poster_dpi,
    #     margin_in=poster_margin_inches,
    #     spacing_in=poster_spacing_inches,
    #     poster_title=f"Layout: {chosen_template_name.replace('_', ' ').title()}",
    #     # ... other preview parameters
    # )
    print(f"Preview would be saved to: {os.path.join(output_folder, f'preview_{chosen_template_name}.png')}")


    # 4. Calculate required sizes for your individual story shape PNGs
    # Assuming calculate_cell_content_size is defined
    print("\n--- Required content sizes for each cell (at 300 DPI for print) ---")
    for i, cell_def in enumerate(template_details['grid_template']):
        # target_size_px = calculate_cell_content_size(
        #     poster_width_in=poster_width_inches,
        #     poster_height_in=poster_height_inches,
        #     dpi=300, # Target DPI for your story shapes
        #     margin_in=poster_margin_inches,
        #     spacing_in=poster_spacing_inches,
        #     base_rows=template_details['base_rows'],
        #     base_cols=template_details['base_cols'],
        #     cell_row_span=cell_def['row_span'],
        #     cell_col_span=cell_def['col_span']
        # )
        # if target_size_px:
        #     print(f"Cell for content_index {cell_def['content_index']} (Span {cell_def['row_span']}x{cell_def['col_span']}): "
        #           f"Target story shape content size = {target_size_px[0]} x {target_size_px[1]} pixels")
        # else:
        #     print(f"Could not calculate size for cell_def: {cell_def}")
        pass # Placeholder for brevity, uncomment if running with your functions

    # 5. Prepare your story_shape_paths (list of N PNGs, correctly sized)
    #    story_files = ["path/to/story0.png", "path/to/story1.png", ...]
    #    Ensure len(story_files) == template_details['num_stories']

    # 6. Create the actual poster (if you have create_poster function)
    # create_poster(
    #     story_shape_paths=story_files, # Your list of N image paths
    #     poster_width_in=poster_width_inches,
    #     poster_height_in=poster_height_inches,
    #     output_path=os.path.join(output_folder, f"poster_{chosen_template_name}.png"),
    #     base_rows=template_details['base_rows'],
    #     base_cols=template_details['base_cols'],
    #     grid_template=template_details['grid_template'],
    #     dpi=300, # For print quality
    #     margin_in=poster_margin_inches,
    #     spacing_in=poster_spacing_inches,
    #     poster_title="My Awesome Story Poster",
    #     # ... other poster parameters
    # )
    print(f"\nActual poster would use {template_details['num_stories']} story shapes and be saved to: {os.path.join(output_folder, f'poster_{chosen_template_name}.png')}")

    print("\n--- All Available Templates ---")
    for name, details in poster_layout_templates.items():
        print(f"- {name}: {details['description']} (expects {details['num_stories']} stories, {details['base_rows']}x{details['base_cols']} base grid)")





template_name = "stories6_2x3_grid" # Example
my_layout = poster_layout_templates[template_name]

num_expected_stories = my_layout["num_stories"]
base_r = my_layout["base_rows"]
base_c = my_layout["base_cols"]
grid_def = my_layout["grid_template"]

# ==============================================================================
#  CONTENTS FROM: story_shape.py
# ==============================================================================

# Import necessary libraries
import cairo
import gi
import numpy as np
import math
from shapely.geometry import Polygon
from shapely.affinity import rotate as shapely_rotate
import shapely.affinity
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
import yaml
import copy
from scipy.interpolate import CubicSpline
import json
import os
import random 
import os
import json
import matplotlib.font_manager as fm

# Ensure the correct versions of Pango and PangoCairo are used
gi.require_version('Pango', '1.0')
gi.require_version('PangoCairo', '1.0')
from gi.repository import Pango, PangoCairo

import anthropic
import yaml

CURRENT_DPI = 300
MAX_SPACING_ADJUSTMENT_ATTEMPTS = 1000

def create_shape(
                config_path,
                output_dir, # <-- NEW ARGUMENT
                story_data_dir, # <-- NEW ARGUMENT for data files
                story_data_path,
                product = "canvas",
                x_delta = 0.015,
                step_k = 15,
                max_num_steps = 3, #for step by step function; set to 2 for 8x10 and 3 for 12x12
                font_style="",
                font_size=72,
                font_color = (0, 0, 0), #default to black
                line_type = 'char',
                line_thickness = 2,
                line_color = (0,0,0),
                background_type='solid', 
                background_value=(1, 1, 1), 
                has_title = "NO", #values YES or NO
                title_text = "", #optionl if left blank then title used 
                title_font_style = "",
                title_font_size=96,
                title_font_color = (0, 0, 0),#default to black
                title_font_bold = False, #can be True or False
                title_font_underline = False,
                title_padding = 20,
                gap_above_title = 20,
                protagonist_text = "",
                protagonist_font_style = "Cormorant Garamond",
                protagonist_font_size= 12, 
                protagonist_font_color= (0, 0 , 0),
                protagonist_font_bold = False,
                protagonist_font_underline = False,
                author_text="", # Optional, defaults to story_data['author']
                author_font_style="Cormorant Garamond", # Defaults to title font style if empty
                author_font_size=12, # Suggest smaller than title
                author_font_color='#000000', # Use hex, defaults to title color
                author_font_bold=False,
                author_font_underline=False,
                author_padding=5, # Vertical space BETWEEN title and author
                top_text = "", #only applies when wrapped > 0; if "" will default to author, year
                top_text_font_style = "Cormorant Garamond",
                top_text_font_size = "24",
                top_text_font_color = "#1F4534",
                bottom_text = "", #only applies when wrapped > 0; if "" will default to "Shapes of Stories"
                bottom_text_font_style = "Sans",
                bottom_text_font_size = "12",
                bottom_text_font_color = "#000000",
                top_and_bottom_text_band = 1.5,
                border = False,
                border_thickness=4,
                border_color=(0, 0, 0),
                width_in_inches = 15,
                height_in_inches = 15,
                wrap_in_inches=1.5,
                wrap_background_color = (0,0,0),
                fixed_margin_in_inches=0.625,
                recursive_mode = True,
                recursive_loops = 500,
                llm_provider = "anthropic",
                llm_model = "claude-3-5-sonnet-latest",
                output_format="png"):
    

    fonts_to_check = {
        "Body Font": font_style,
        "Title Font": title_font_style,
        "Protagonist Font": protagonist_font_style,
        "Author Font":author_font_style,
        "Top Text Font": top_text_font_style,
        "Bottom Text Font": bottom_text_font_style,
    }
    # for desc, font in fonts_to_check.items():
    #     if font and not pango_font_exists(font):
    #         raise ValueError(f"{desc} '{font}' not found on this system.")
    

    #save hex values 
    font_color_hex = font_color
    background_value_hex = background_value
    border_color_hex = border_color

    #convert hex colors to (x,y,z) foramt
    font_color = hex_to_rgb(font_color)
    line_color = hex_to_rgb(line_color)
    title_font_color = hex_to_rgb(title_font_color)
    protagonist_font_color = hex_to_rgb(protagonist_font_color)
    author_font_color = hex_to_rgb(author_font_color)
    top_text_font_color = hex_to_rgb(top_text_font_color)
    bottom_text_font_color = hex_to_rgb(bottom_text_font_color)
    border_color = hex_to_rgb(border_color)
    background_value = hex_to_rgb(background_value)
    wrap_background_color = hex_to_rgb(wrap_background_color)


    with open(story_data_path, 'r', encoding='utf-8') as file:
        story_data = json.load(file)
        if 'story_plot_data' in story_data:
            story_data = story_data['story_plot_data']
    
    #get title 
    path_title = story_data['title'].lower().replace(' ', '-')
    path_size = f'{width_in_inches}x{height_in_inches}'
    path_protagonist= story_data['protagonist'].lower().replace(' ', '-')
    

    #check_path = f'/Users/johnmikedidonato/Projects/TheShapesOfStories/data/story_data/{path_title}_{path_protagonist}_{path_size}.json'
    # Use os.path.join with the new story_data_dir argument
    check_path = os.path.join(story_data_dir, f'{path_title}_{path_protagonist}_{path_size}.json')
    
    if os.path.exists(check_path):
        story_data_path = check_path
        print("Story Data for " , path_size ," exists")
        with open(story_data_path, 'r', encoding='utf-8') as file:
            story_data = json.load(file)
            if 'story_plot_data' in story_data:
                story_data = story_data['story_plot_data']

    #create story_shape_path

    story_shape_product = "product-" + product
    story_shape_line_type = "line-type-" + line_type
    story_shape_title = "title-" + story_data['title'].lower().replace(' ', '-')
    story_shape_size = "size-" + f'{width_in_inches}x{height_in_inches}'
    story_shape_protagonist = "protagonist-"+story_data['protagonist'].lower().replace(' ', '-')
    story_shape_background_color = "background-color-" + background_value_hex
    story_shape_font_color = "font-color-" + font_color_hex
    story_shape_border_color = "border-color-" + border_color_hex
    story_shape_font = "font-"+font_style
    print(font_style)

    if title_text == "":
        story_shape_title_display = "title-display-yes"
    else:
        story_shape_title_display = "title-display-no"

    unique_filename = (
        f"{story_shape_title}_{story_shape_protagonist}_{story_shape_product}_"
        f"{story_shape_size}_{story_shape_line_type}_{story_shape_background_color}_"
        f"{story_shape_font_color}_{story_shape_border_color}_{story_shape_font}_"
        f"{story_shape_title_display}.{output_format}"
    )

    #story_shape_path = f'/Users/johnmikedidonato/Projects/TheShapesOfStories/data/story_shapes/{story_shape_title}_{story_shape_protagonist}_{story_shape_product}_{story_shape_size}_{story_shape_line_type}_{line_type}_{story_shape_background_color}_{story_shape_font_color}_{story_shape_border_color}_{story_shape_font}_{story_shape_title_display}.{output_format}'
    story_shape_path = os.path.join(output_dir, unique_filename)

   
    status = "processing"
    story_data['status'] = status
    count = 1
    print("starting...")
    # while status == "processing":
    for i in range(recursive_loops):
        # print(story_data['story_components'][1]['modified_end_time'])
        print("loop #", i)
        if story_data is None:
            print("STORY DATA NONE")

        story_data = transform_story_data(story_data, x_delta, step_k, max_num_steps)

        story_data, status = create_shape_single_pass(
                    config_path=config_path,
                    story_data=story_data, 
                    font_style=font_style,
                    font_size=font_size,
                    font_color = font_color,
                    line_type=line_type,
                    line_thickness = line_thickness,
                    line_color = line_color,
                    background_type=background_type, 
                    background_value=background_value, 
                    has_title = has_title,
                    title_text=title_text,
                    title_font_style=title_font_style,
                    title_font_size=title_font_size,
                    title_font_color = title_font_color,
                    title_font_bold = title_font_bold, 
                    title_font_underline = title_font_underline,
                    title_padding = title_padding,
                    gap_above_title = gap_above_title,
                    protagonist_text = protagonist_text,
                    protagonist_font_style = protagonist_font_style,
                    protagonist_font_size= protagonist_font_size, 
                    protagonist_font_color= protagonist_font_color,
                    protagonist_font_bold = protagonist_font_bold,
                    protagonist_font_underline = protagonist_font_underline,
                    author_text=author_text, # Optional, defaults to story_data['author']
                    author_font_style=author_font_style, # Defaults to title font style if empty
                    author_font_size=author_font_size, # Suggest smaller than title
                    author_font_color=author_font_color, # Use hex, defaults to title color
                    author_font_bold=author_font_bold,
                    author_font_underline=author_font_underline,
                    author_padding=author_padding, 
                    top_text = top_text, #only applies when wrapped > 0; if "" will default to author, year
                    top_text_font_style = top_text_font_style,
                    top_text_font_size = top_text_font_size,
                    top_text_font_color = top_text_font_color,
                    bottom_text = bottom_text, #only applies when wrapped > 0; if "" will default to "Shapes of Stories"
                    bottom_text_font_style = bottom_text_font_style,
                    bottom_text_font_size = bottom_text_font_size,
                    bottom_text_font_color = bottom_text_font_color,
                    top_and_bottom_text_band = top_and_bottom_text_band,
                    border = border,
                    border_thickness=border_thickness,
                    border_color=border_color,
                    width_in_inches=width_in_inches,
                    height_in_inches=height_in_inches,
                    wrap_in_inches=wrap_in_inches,
                    wrap_background_color = wrap_background_color,
                    fixed_margin_in_inches=fixed_margin_in_inches,
                    story_shape_path=story_shape_path,
                    recursive_mode=recursive_mode,
                    llm_provider = llm_provider,
                    llm_model = llm_model,
                    output_format = output_format)

        #print(count, " .) ", status)
        if(count % 50 == 0):
            print(count)

        count = count + 1
        if status == "completed" or status == "error":
            story_data['status'] = status
            break
        #print(story_data['story_components'][1]['modified_end_time'])



    #clean up story_data for saving
    del story_data['x_values']
    del story_data['y_values']
    for component in story_data['story_components']:

        if 'arc_x_values' in component:
            del component['arc_x_values']

        if 'arc_y_values' in component:
            del component['arc_y_values']


    #set new path
    story_data['font_size'] = font_size
    story_data['font_style'] = font_style
    story_data['font_color'] = font_color
    story_data['line_thickness'] = line_thickness
    story_data['title_font_size'] = title_font_size
    story_data['title_font_style'] = title_font_style
    story_data['title_font_color'] = title_font_color
    story_data['protagonist_font_size'] = protagonist_font_size
    story_data['protagonist_font_style'] = protagonist_font_style
    story_data['protagonist_font_color'] = protagonist_font_color
    story_data['background_color'] = background_value
    story_data['border_thickness'] = border_thickness
    story_data['border_color'] = border_color
    story_data['arc_text_llm'] = llm_model
    story_data['fixed_margin_in_inches'] = fixed_margin_in_inches
    new_title = story_data['title'].lower().replace(' ', '-')
    new_size = f'{width_in_inches}x{height_in_inches}'
    new_protagonist = story_data['protagonist'].lower().replace(' ', '-')
    
    
    
    #new_story_data_path = f'/Users/johnmikedidonato/Projects/TheShapesOfStories/data/story_data/{new_title}_{new_protagonist}_{new_size}.json'
    # Use os.path.join with the new story_data_dir argument
    new_story_data_filename = f'{new_title}_{new_protagonist}_{new_size}.json'
    new_story_data_path = os.path.join(story_data_dir, new_story_data_filename)
    
    with open(new_story_data_path, 'w', encoding='utf-8') as file:
        json.dump(story_data, file, ensure_ascii=False, indent=4)

    return new_story_data_path, story_shape_path


def create_shape_single_pass(
                config_path,
                story_data, 
                font_style="",
                font_size=72,
                font_color = (0, 0, 0), #default to black
                line_type = 'char',
                line_thickness = 2,
                line_color = (0,0,0),
                background_type='solid', 
                background_value=(1, 1, 1), 
                has_title = "NO",
                title_text = "",
                title_font_style = "",
                title_font_size=96,
                title_font_color = (0, 0 , 0), #default to black
                title_font_bold = False, 
                title_font_underline = False,
                title_padding = 20,
                gap_above_title = 20,
                protagonist_text = "",
                protagonist_font_style = "Cormorant Garamond",
                protagonist_font_size= 12, 
                protagonist_font_color= (0, 0 , 0),
                protagonist_font_bold = False,
                protagonist_font_underline = False,
                author_text="", # Optional, defaults to story_data['author']
                author_font_style="Cormorant Garamond", # Defaults to title font style if empty
                author_font_size=12, # Suggest smaller than title
                author_font_color='#000000', # Use hex, defaults to title color
                author_font_bold=False,
                author_font_underline=False,
                author_padding=5, # Vertical space BETWEEN title and author
                top_text = "", #only applies when wrapped > 0; if "" will default to author, year
                top_text_font_style = "Cormorant Garamond",
                top_text_font_size = "24",
                top_text_font_color = (0, 0 , 0),
                bottom_text = "", #only applies when wrapped > 0; if "" will default to "Shapes of Stories"
                bottom_text_font_style = "Sans",
                bottom_text_font_size = "12",
                bottom_text_font_color = (0, 0 , 0),
                top_and_bottom_text_band = 1.5,
                border=False,
                border_thickness=4,
                border_color=(0, 0, 0),
                width_in_inches = 15,
                height_in_inches = 15,
                wrap_in_inches=1.5,
                fixed_margin_in_inches = 0.625,
                wrap_background_color = (0,0,0),
                story_shape_path = "test",
                recursive_mode = True,
                llm_provider = "anthropic",
                llm_model = "claude-3-5-sonnet-latest",
                output_format = "png"):
    
    """
    Creates the shape with story data and optionally sets the background 
    and draws a title in a dedicated space at the bottom.

    Parameters:
    - story_data: dict containing story arcs and optional 'title', 'author' fields
    - font_style: string, e.g. "Arial" for font face
    - background_type: str, one of 'transparent', 'solid'
    - background_value: 
        if 'solid', tuple (r, g, b) for background color
        if 'transparent', ignored
    - line_type: 'char' (text along arcs) or 'line' (just a line)
    - has_title: "YES" or "NO" (whether to reserve space and draw a title)
    - title_font_style, title_font_size, title_font_color: style for the title
    - width_in_inches, height_in_inches: final image size in inches
    - recursive_mode: whether to keep adjusting arcs if they're too short/long
    """

    ### START OF DEBUG ###
    # --- ADD DEBUG COLORS ---
    # debug_segment_colors_rgb = [
    #     hex_to_rgb("#FF0000"), # Red
    #     hex_to_rgb("#00FF00"), # Green
    #     hex_to_rgb("#0000FF"), # Blue
    #     hex_to_rgb("#FFFF00"), # Yellow
    #     hex_to_rgb("#FF00FF"), # Magenta
    #     hex_to_rgb("#00FFFF"), # Cyan
    #     hex_to_rgb("#FFA500"), # Orange
    #     hex_to_rgb("#800080"), # Purple
    #     hex_to_rgb("#A52A2A"), # Brown
    #     hex_to_rgb("#FFFFFF")  # White (for markers, if background is dark)
    # ]
    # color_cycle = itertools.cycle(debug_segment_colors_rgb)
    # marker_color_rgb = hex_to_rgb("#000000") # Black for markers, or choose a contrast color
    # if sum(background_value) < 1.5: # If background is dark-ish
    #     marker_color_rgb = hex_to_rgb("#FFFFFF") # Use white markers


    ### END OF DEBUG ###

    # Extract the overall x_values and y_values (scaled from transform_story_data)
    x_values = story_data['x_values']  # Scaled x_values (from 1 to 10)
    y_values = story_data['y_values']  # Scaled y_values (from -10 to 10)

    # Extract original end_time and end_emotional_score values
    original_end_times = [component['end_time'] for component in story_data['story_components']]
    original_emotional_scores = [component['end_emotional_score'] for component in story_data['story_components']]

    # Get the original min and max values from your data
    old_min_x = min(original_end_times)
    old_max_x = max(original_end_times)
    old_min_y = min(original_emotional_scores)
    old_max_y = max(original_emotional_scores)

    # Set the scaling ranges used in transform_story_data
    new_min_x, new_max_x = 1, 10
    new_min_y, new_max_y = -10, 10

  
    # total print area
    total_width_in = width_in_inches + 2*wrap_in_inches
    total_height_in = height_in_inches + 2*wrap_in_inches

    total_width_px = int(total_width_in * CURRENT_DPI)
    total_height_px = int(total_height_in * CURRENT_DPI)


    #SETUP FONTS
    from gi.repository import Pango
    font_size_for_300dpi = font_size * (CURRENT_DPI / 72)
    font_desc = Pango.FontDescription(f"{font_style} {font_size_for_300dpi}")

    title_font_size_for_300dpi = title_font_size * (CURRENT_DPI / 72)
    title_font_desc = Pango.FontDescription(f"{title_font_style} {title_font_size_for_300dpi}")
    if title_font_bold == True:
        title_font_desc.set_weight(Pango.Weight.BOLD)

    protagonist_font_size_for_300dpi = protagonist_font_size * (CURRENT_DPI/72)
    protagonist_font_desc = Pango.FontDescription(f"{protagonist_font_style} {protagonist_font_size_for_300dpi}")
    if protagonist_font_bold == True:
        protagonist_font_desc.set_weight(Pango.Weight.BOLD)

    # Prepare Author Font Desc (using effective style passed in)
    author_font_size_for_300dpi = author_font_size * (CURRENT_DPI / 72)
    author_font_desc = Pango.FontDescription(f"{author_font_style} {author_font_size_for_300dpi}")
    if author_font_bold: author_font_desc.set_weight(Pango.Weight.BOLD)


    top_text_font_size_for_300dpi = top_text_font_size * (CURRENT_DPI/72)
    top_text_font_desc = Pango.FontDescription(f"{top_text_font_style} {top_text_font_size_for_300dpi}")

    bottom_text_font_size_for_300dpi = bottom_text_font_size * (CURRENT_DPI/72)
    bottom_text_font_desc = Pango.FontDescription(f"{bottom_text_font_style} {bottom_text_font_size_for_300dpi}")

    # Create a Cairo surface and context
    import cairo
     # create the surface
    if output_format=="svg":
        surface = cairo.SVGSurface(story_shape_path, total_width_px, total_height_px)
    else:
        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, total_width_px, total_height_px)
    cr = cairo.Context(surface)

    from gi.repository import Pango, PangoCairo
    pangocairo_context = PangoCairo.create_context(cr)

    # Calculate dimensions
    design_offset_x = wrap_in_inches * CURRENT_DPI
    design_offset_y = wrap_in_inches * CURRENT_DPI
    design_width = int(width_in_inches * CURRENT_DPI)
    design_height = int(height_in_inches * CURRENT_DPI)

    # Paint wrap areas
    if wrap_in_inches > 0:
        cr.save()
        cr.set_source_rgb(*wrap_background_color)
        
        # Top wrap area
        cr.rectangle(0, 0, total_width_px, wrap_in_inches * CURRENT_DPI)
        cr.fill()
        
        # Bottom wrap area
        bottom_y = total_height_px - (wrap_in_inches * CURRENT_DPI)
        cr.rectangle(0, bottom_y, total_width_px, wrap_in_inches * CURRENT_DPI)
        cr.fill()
        
        # Left wrap area
        cr.rectangle(0, wrap_in_inches * CURRENT_DPI, wrap_in_inches * CURRENT_DPI, height_in_inches * CURRENT_DPI)
        cr.fill()
        
        # Right wrap area
        right_x = total_width_px - (wrap_in_inches * CURRENT_DPI)
        cr.rectangle(right_x, wrap_in_inches * CURRENT_DPI, wrap_in_inches * CURRENT_DPI, height_in_inches * CURRENT_DPI)
        cr.fill()
        
        cr.restore()

        # Now translate for main design
        cr.save()
        cr.translate(design_offset_x, design_offset_y)
    else:
        
        # Now translate for main design
        cr.save()
        cr.translate(design_offset_x, design_offset_y)

    # Paint main background
    if background_type == 'transparent':
        cr.rectangle(0, 0, design_width, design_height)
        cr.set_source_rgba(0, 0, 0, 0)
        cr.set_operator(cairo.OPERATOR_SOURCE)
        cr.fill()
        cr.set_operator(cairo.OPERATOR_OVER)
    elif background_type == 'solid':
        cr.rectangle(0, 0, design_width, design_height)
        cr.set_source_rgb(*background_value)
        cr.fill()
    


    if border:
        cr.save()
        cr.set_source_rgb(*border_color)
        cr.set_line_width(border_thickness)
        cr.rectangle(0, 0, design_width, design_height)
        cr.stroke()
        cr.restore()

     # Set margins in inches and convert to pixels
    # Now define margins *inside* that design region
    margin_x = round(fixed_margin_in_inches * CURRENT_DPI)
    margin_y = round(fixed_margin_in_inches * CURRENT_DPI)

    # Determine data range for x and y
    x_min = min(x_values)
    x_max = max(x_values)
    y_min = min(y_values)
    y_max = max(y_values)
    x_range = x_max - x_min
    y_range = y_max - y_min

   # 3) If we have a title, measure its pixel height

     # --- MODIFIED: Calculate Title/Author Band Height ---
    measured_title_height = 0
    measured_author_height = 0
    title_band_height = 0 # Total height reserved at the bottom
    effective_author_text = "" # Store measured author text

    if has_title == "YES":
        effective_title_text = title_text if title_text else story_data.get('title', '')
        if effective_title_text:
            layout_temp_title = PangoCairo.create_layout(cr)
            layout_temp_title.set_font_description(title_font_desc)
            layout_temp_title.set_text(effective_title_text, -1)
            _, measured_title_height = layout_temp_title.get_pixel_size()
            title_band_height += measured_title_height # Start with title height

            if author_text != "":
                effective_author_text = author_text
                if effective_author_text:
                    layout_temp_author = PangoCairo.create_layout(cr)
                    layout_temp_author.set_font_description(author_font_desc)
                    layout_temp_author.set_text(effective_author_text, -1)
                    _, measured_author_height = layout_temp_author.get_pixel_size()
                    # Add padding *between* title and author, then author height
                    title_band_height += author_padding + measured_author_height
                else:
                    # No author text, just add the title's own bottom padding
                    title_band_height += title_padding
            else:
                # No author requested, add title's own bottom padding
                 title_band_height += title_padding
        else:
            # No title text, band height is 0
            has_title = "NO" # Cannot draw title if text is empty
            has_author = "NO" # Cannot draw author if title isn't drawn

    # If title_band_height is still 0 (no title/author), set has_title/has_author to NO
    if title_band_height == 0:
        has_title = "NO"
        has_author = "NO"


    drawable_width = design_width - 2 * margin_x
    drawable_height = (design_height
                       - 2 * margin_y
                       - title_band_height # Use the combined height
                       - gap_above_title)

    if drawable_height <= 0:
         raise ValueError("Drawable height is zero or negative. Check margins, font sizes, paddings.")
    # --- END MODIFIED BAND HEIGHT & DRAWABLE AREA ---
    
    # 4) Compute scale factors & map your story arcs into [margin_y, margin_y+drawable_height]
    x_values = story_data['x_values']
    y_values = story_data['y_values']
    x_min, x_max = min(x_values), max(x_values)
    y_min, y_max = min(y_values), max(y_values)
    x_range = x_max - x_min
    y_range = y_max - y_min

    scale_x = drawable_width / x_range if x_range else 1
    scale_y = drawable_height / y_range if y_range else 1

    # The bottom edge for arcs is margin_y + drawable_height
    x_values_scaled = [(x - x_min)*scale_x + margin_x for x in x_values]
    y_values_scaled = [
        (margin_y + drawable_height) - ((y - y_min)*scale_y)
        for y in y_values
    ]

    # Create a mapping from original to scaled coordinates
    coordinate_mapping = dict(zip(zip(x_values, y_values), zip(x_values_scaled, y_values_scaled)))

    # Now ready to draw arcs/text
    title = story_data.get('title', '')
    author = story_data.get('author', '')

    # -------------------------------------------------------------
    # Remove the old "title at top" code.
    # We'll draw the title *after* arcs, at the very bottom.
    # -------------------------------------------------------------

    # If line_type = 'line', just draw a line
    if line_type == "line":
        cr.set_source_rgb(*line_color)
        cr.set_line_width(line_thickness)

        cr.move_to(x_values_scaled[0], y_values_scaled[0])
        for sx, sy in zip(x_values_scaled[1:], y_values_scaled[1:]):
            cr.line_to(sx, sy)
        cr.stroke()

            # Respect output_format here
        

    elif line_type == "char":
        from scipy.interpolate import CubicSpline
        import numpy as np
        import copy
        begin_svg_group(cr, "main-text-path", output_format)
        
        

        # # Prepare for text on arcs
        # from gi.repository import Pango
        # font_size_for_300dpi = font_size * (300 / 96)
        # font_desc = Pango.FontDescription(f"{font_style} {font_size_for_300dpi}")
        arc_sample_text = ""
        all_rendered_boxes = []
        status = "completed"

        last_story_component_index = last_index = len(story_data['story_components']) - 1 

        for index, component in enumerate(story_data['story_components'][1:], start=1):
            arc_x_values = component.get('arc_x_values', [])
            arc_y_values = component.get('arc_y_values', [])
            description = component.get('description', '')

            if 'adjust_spacing' not in component:
                component['adjust_spacing'] = False

            if 'arc_manual_override' not in component:
                component['arc_manual_override'] = False
            
            if 'spacing_factor' not in component:
                component['spacing_factor'] = 1

            if not arc_x_values or not arc_y_values:
                continue

            # Scale arc coordinates
            arc_x_values_scaled = []
            arc_y_values_scaled = []
            for (xx, yy) in zip(arc_x_values, arc_y_values):
                if (xx, yy) in coordinate_mapping:
                    arc_x_values_scaled.append(coordinate_mapping[(xx, yy)][0])
                    arc_y_values_scaled.append(coordinate_mapping[(xx, yy)][1])
                else:
                    # fallback
                    sx = (xx - x_min) * scale_x + margin_x
                    sy = (margin_y + drawable_height) - ((yy - y_min) * scale_y)
                    arc_x_values_scaled.append(sx)
                    arc_y_values_scaled.append(sy)

            # Reverse scaling functions
            def reverse_scale_plot_points(scaled_x, old_min, old_max, new_min=1, new_max=10):
                return ((scaled_x - new_min) / (new_max - new_min)) * (old_max - old_min) + old_min

            def reverse_scale_y_values(scaled_y, old_min, old_max, new_min=-10, new_max=10):
                return ((scaled_y - new_min) / (new_max - new_min)) * (old_max - old_min) + old_min

            original_arc_end_time_values = [
                reverse_scale_plot_points(xv, old_min_x, old_max_x, new_min_x, new_max_x)
                for xv in arc_x_values
            ]
            original_arc_end_emotional_score_values = [
                reverse_scale_y_values(yv, old_min_y, old_max_y, new_min_y, new_max_y)
                for yv in arc_y_values
            ]

            # Draw the arc path (invisible stroke first)
            cr.set_line_width(2)
            cr.move_to(arc_x_values_scaled[0], arc_y_values_scaled[0])
            for sx, sy in zip(arc_x_values_scaled[1:], arc_y_values_scaled[1:]):
                cr.line_to(sx, sy)

            cr.set_source_rgba(0, 0, 0, 0)  # invisible
            cr.stroke()


            ### START OF BEBUG ###
            # --- DEBUG: DRAW THE CURVE SEGMENT ITSELF (thin line in its color) ---
            # current_segment_color_debug = next(color_cycle) # Get color for this debug segment
            # cr.save()
            # cr.set_source_rgb(*current_segment_color_debug)
            # cr.set_line_width(max(2, line_thickness / 5)) # Draw a thinner line for the segment path itself for debug
            # cr.move_to(arc_x_values_scaled[0], arc_y_values_scaled[0])
            # for sx_seg, sy_seg in zip(arc_x_values_scaled[1:], arc_y_values_scaled[1:]):
            #     cr.line_to(sx_seg, sy_seg)
            # cr.stroke()
            # cr.restore()

            # # --- DEBUG: DRAW MARKERS FOR START AND END OF THIS SCALED SEGMENT ---
            # # Marker at the start of this segment
            # current_segment_color_debug = next(color_cycle) # Get color for this debug segment
            # cr.save()
            # cr.set_source_rgb(*current_segment_color_debug) # Use a contrasting marker color
            # cr.arc(arc_x_values_scaled[0], arc_y_values_scaled[0], 7, 0, 2 * math.pi) # 7px radius circle
            # cr.fill()
            # # Optionally, add a number to the marker
            # layout_marker_idx = PangoCairo.create_layout(cr)
            # font_desc_marker = Pango.FontDescription(f"Sans Bold 12") # Small font for index
            # layout_marker_idx.set_font_description(font_desc_marker)
            # layout_marker_idx.set_text(str(index), -1)
            # mk_w, mk_h = layout_marker_idx.get_pixel_size()
            # cr.move_to(arc_x_values_scaled[0] + 10, arc_y_values_scaled[0] - mk_h / 2) # Offset slightly
            # PangoCairo.show_layout(cr, layout_marker_idx)
            # cr.restore()

            # # Marker at the end of this segment
            # cr.save()
            # cr.set_source_rgb(*marker_color_rgb)
            # cr.arc(arc_x_values_scaled[-1], arc_y_values_scaled[-1], 7, 0, 2 * math.pi)
            # cr.fill()
            # cr.restore()

            ### END OF BEBUG ###











            # Now set real color for text
            cr.set_source_rgb(*font_color)

            # Calculate arc length
            arc_length = calculate_arc_length(arc_x_values_scaled, arc_y_values_scaled)
            #ADDING 5/18/2025
            #average_rotation_angle = calculate_average_rotation_angle(arc_x_values_scaled, arc_y_values_scaled)


            # If arc_text not generated yet, do so

            create_descriptor = True
            if 'arc_text_valid' in component:
                if component['arc_text_valid'] == True:
                    create_descriptor = False
                
            if create_descriptor:

                if 'target_arc_text_chars' not in component:
                    #calculate target chars based on estimate of the number of chars that could fit in arc segment
                    average_char_width = get_average_char_width(pangocairo_context, font_desc, arc_sample_text)
                    average_rotation_angle = calculate_average_rotation_angle(arc_x_values_scaled, arc_y_values_scaled)
                    target_chars = estimate_characters_fit(arc_length, average_char_width, average_rotation_angle)
                    component['target_arc_text_chars'] = target_chars
                else:
                    target_chars = component['target_arc_text_chars']

                if target_chars < 5:
                    continue

                if index == 1 or index == last_story_component_index:
                    llm_target_chars = target_chars #set llm_target_chars to target chars because there's no net calc needed at this point
                else: #calc llm_target_chars considering net
                    llm_target_chars = target_chars - (story_data['story_components'][index - 1]['actual_arc_text_chars'] - story_data['story_components'][index - 1]['target_arc_text_chars_with_net'] )
                
                print("STORY COMPONENT INDEX: ", index)
                print("")

                if 'arc_text_valid_message' in component:
                    if component['arc_text_valid_message'] == "curve too long but can't change due to constraints":
                        print("old target chars: ", target_chars)
                        target_chars = target_chars + 3
                        component['target_arc_text_chars'] = target_chars
                        llm_target_chars = target_chars
                        print("updated target chars: ", llm_target_chars)
                    elif component['arc_text_valid_message'] == "curve too short but can't change due to constraints":
                        print("old target chars: ", target_chars)
                        target_chars = target_chars - 3
                        component['target_arc_text_chars'] = target_chars
                        llm_target_chars = target_chars
                        print("updated target chars: ", llm_target_chars)
                
                component['target_arc_text_chars_with_net'] = llm_target_chars #save net target in story data dict so it can be referenced in future 
                lower_bound = llm_target_chars - 3
                upper_bound = llm_target_chars + 3
                

                # Generate descriptors 
                descriptors_valid = False 
                reasonable_descriptiors_attempts = 1

                #generate descriptors 
                while descriptors_valid == False and reasonable_descriptiors_attempts <= 5:
                    descriptors_text = generate_descriptors(
                        title=story_data['title'],
                        author=story_data['author'],
                        protagonist=story_data['protagonist'],
                        component_description=description,
                        story_data=story_data,
                        desired_length=llm_target_chars,
                        llm_provider=llm_provider,
                        llm_model=llm_model,
                        config_path=config_path
                    )

                    descriptors_valid, descriptor_message = validate_descriptors(
                        descriptors_text=descriptors_text,
                        protagonist=story_data['protagonist'],
                        lower_bound=lower_bound,
                        upper_bound=upper_bound
                    )

                    #update descriptors text immediately if valid 
                    if descriptors_valid == True:
                        descriptors_text = descriptor_message

                      #if descriptors valid and it's the last index then remove the trailing space
                        if index == last_story_component_index:
                            if descriptors_text.endswith(' '): #check if ends in space
                                descriptors_text = descriptors_text[:-1] #remove last character (the space)
                                

                             
                    if 'arc_text' not in component:
                         component['arc_text_attempts'] = 1
                    else:
                        component['arc_text_attempts'] = component['arc_text_attempts'] + 1

                    component['arc_text'] = descriptors_text
                    component['actual_arc_text_chars'] = len(descriptors_text)
                    component['arc_text_valid'] = descriptors_valid
                    component['arc_text_valid_message'] = descriptor_message

                    
                   

                    actual_chars = len(descriptors_text)

                    if descriptors_valid == True:
                        print("#", reasonable_descriptiors_attempts,".) Descriptors Valid: ", descriptors_text, "(",actual_chars,"/",str(upper_bound-3),") -- LLM Char Target: ", llm_target_chars )

                        component['spaces_in_arc_text'] = component['arc_text'].count(' ')
                        component['spaces_width_multiplier'] = {}
                        component['space_to_modify'] = 0
                        for space_index in range(component['spaces_in_arc_text']):
                            component['spaces_width_multiplier'][space_index] = 1.0
                        component['spacing_adjustment_attempts'] = 0 # Reset total attempts for this new text
                        component['spacing_factor'] = 1
                        component['adjust_spacing'] = False
                        component['modified_end_time'] = component['end_time']
                        component['modified_end_emotional_score'] = component['end_emotional_score']
                    
                    else:
                        print("#", reasonable_descriptiors_attempts,".) Descriptors NOT Valid: ", descriptors_text, "Target Chars: ", llm_target_chars, " Error: ",  descriptor_message)

                        if (actual_chars - target_chars) > 50:
                            llm_target_chars = llm_target_chars - random.randint(20, 30) #if descriptors not even close > 10 chars away
                        elif (actual_chars - target_chars) > 20 and (actual_chars - target_chars) <= 50:
                            llm_target_chars = llm_target_chars - random.randint(13, 17) #if descriptors not even close > 10 chars away
                        elif (actual_chars - target_chars) > 10 and (actual_chars - target_chars) <= 20:
                            llm_target_chars = llm_target_chars - random.randint(4, 9) #if descriptors not even close > 10 chars away
                        elif (actual_chars - target_chars) > 5 and (actual_chars - target_chars) <= 10:
                            llm_target_chars = llm_target_chars - random.randint(3, 5) #if descriptors not even close > 10 chars away
                        elif (actual_chars - target_chars) > 0 and (actual_chars - target_chars) <= 5:
                            llm_target_chars = llm_target_chars - random.randint(1, 2) #if descriptors not even close > 10 chars away
                        elif (actual_chars - target_chars) < 0 and (actual_chars - target_chars) >= -5:
                            llm_target_chars = llm_target_chars + random.randint(1, 2)
                        elif (actual_chars - target_chars) < -5 and (actual_chars - target_chars) >= -10:
                            llm_target_chars = llm_target_chars + random.randint(3, 4)
                        elif (actual_chars - target_chars) < -10:
                            llm_target_chars = llm_target_chars + random.randint(4, 5)
                    
                    reasonable_descriptiors_attempts = reasonable_descriptiors_attempts + 1

                if descriptors_valid == False:
                    if story_data is None:
                        print("STORY DATA NONE -- 9")

                    return story_data, "error"
                
                if component['arc_text_attempts'] > 10:
                    print("Max attempts to create descriptors exceeded")
                    if story_data is None:
                        print("STORY DATA NONE -- 10")
                    return story_data, "error"
                
            else:
                descriptors_text = component['arc_text']
                component['actual_arc_text_chars'] = len(descriptors_text)


            arc_sample_text += " " + descriptors_text

            # --- START OF NEW CALCULATIONS FOR DETAILED MESSAGES ---
            # if descriptors_text:
            #     current_avg_char_width = get_average_char_width(pangocairo_context, font_desc, descriptors_text)
            # else:
            #     current_avg_char_width = get_average_char_width(pangocairo_context, font_desc, "a")

            # if current_avg_char_width > 0:
            #     ideal_chars_for_this_curve = estimate_characters_fit(arc_length, current_avg_char_width, average_rotation_angle)
            # else:
            #     ideal_chars_for_this_curve = 0

            # actual_chars_in_current_text = len(descriptors_text)
            # # --- END OF NEW CALCULATIONS ---

            #  # Convert to NumPy arrays before passing to draw_text_on_curve
            # arc_x_values_scaled_np = np.array(arc_x_values_scaled)
            # arc_y_values_scaled_np = np.array(arc_y_values_scaled)

            # # Calculate arc length
            # # arc_length = calculate_arc_length(arc_x_values_scaled, arc_y_values_scaled) # Original
            # arc_length = calculate_arc_length(arc_x_values_scaled_np, arc_y_values_scaled_np) # Use NP array
            
            # #ADDING 5/18/2025
            # # average_rotation_angle = calculate_average_rotation_angle(arc_x_values_scaled, arc_y_values_scaled) # Original
            # average_rotation_angle = calculate_average_rotation_angle(arc_x_values_scaled_np, arc_y_values_scaled_np) # Use NP array

            
            
            # Draw text on curve
            curve_length_status = draw_text_on_curve(
                cr=cr,
                x_values_scaled=arc_x_values_scaled,
                y_values_scaled=arc_y_values_scaled,
                text=descriptors_text,
                pangocairo_context=pangocairo_context,
                font_desc=font_desc,
                all_rendered_boxes=all_rendered_boxes,
                margin_x=margin_x, 
                margin_y=margin_y, 
                design_width=design_width, 
                design_height=design_height,
                spaces_width_multiplier=component['spaces_width_multiplier'],
                adjust_spacing=component['adjust_spacing']
            )

            min_space_multipler = min(component['spaces_width_multiplier'].values())
            max_space_multipler = max(component['spaces_width_multiplier'].values())
            #print(curve_length_status)
            # Check if curve too short/long, do your recursion logic...
            if curve_length_status == "curve_too_short":
                # Attempt adjusting via CubicSpline
                x_og = np.array(original_arc_end_time_values)
                y_og = np.array(original_arc_end_emotional_score_values)
                sorted_indices = np.argsort(x_og)
                x_og = x_og[sorted_indices]
                y_og = y_og[sorted_indices]

                # Check that we have at least two points before proceeding with CubicSpline
                if len(x_og) < 2:
                    print("CALLING TO SEE IF THERE'S LESS THAN 2 before removing dups")
                    print("original_arc_end_time_values: ", original_arc_end_time_values)

                # Remove duplicates
                tolerance = 1e-12
                unique_indices = [0]
                for i in range(1, len(x_og)):
                    if x_og[i] - x_og[unique_indices[-1]] > tolerance:
                        unique_indices.append(i)
                x_og = x_og[unique_indices]
                y_og = y_og[unique_indices]

                # Check that we have at least two points before proceeding with CubicSpline
                if len(x_og) < 2:
                    print("Not enough points for cubic spline adjustment; skipping cubic spline update.")
                    print("X_og: ", x_og)
                    # You can decide to either return an error status, skip the adjustment, or use a fallback
                    # For instance, set the status to "error" or simply continue:
                    if story_data is None:
                        print("STORY DATA NONE -- 11")

                    return story_data, "error"  # or handle it in another way

                #print("X: ", x_og)
                cs = CubicSpline(x_og, y_og, extrapolate=True)
                new_x = x_og[-1] + (x_og[1] - x_og[0])
                new_y = float(cs(new_x))

                # print(new_x, " , ", new_y)
                # print(old_max_y, " , ", old_min_y)

                #normal mode
                if (new_x >= old_min_x and new_x <= old_max_x 
                    and new_y >= old_min_y and new_y <= old_max_y
                    and recursive_mode
                    and component['adjust_spacing'] == False):
                    component['modified_end_time'] = new_x
                    component['modified_end_emotional_score'] = new_y
                    
                    if output_format == "svg":
                        surface.flush()   # flush the partial drawing, but do *not* finalize!
                    else:
                        surface.write_to_png(story_shape_path)
                    if story_data is None:
                        print("STORY DATA NONE -- 12")

                    return story_data, "processing"

                #this really only works if like this was suppose to be the last story segment
                # we hit x max and want to extend y
                elif ((new_x >= old_max_x or new_x <= old_min_x) and (new_y >= old_min_y and new_y <= old_max_y) and recursive_mode and component['end_time'] == 100 and (round(new_y,2) != round(y_og[-1],2))
                      and component['adjust_spacing'] == False):
                    new_x = x_og[-1]
                    #print(round(new_y,3), " != ", round(y_og[-1],3)) 
                    component['modified_end_time'] = new_x
                    component['modified_end_emotional_score'] = new_y

                    if output_format == "svg":
                        surface.flush()   # flush the partial drawing, but do *not* finalize!
                    else:
                        surface.write_to_png(story_shape_path)
                    if story_data is None:
                        print("STORY DATA NONE -- 13")

                    return story_data, "processing"
                
                # #we hit y max / min and need to extend x
                elif ((new_y >= old_max_y or new_y <= old_min_y) and (new_x >= old_min_x and new_x <= old_max_x) and recursive_mode 
                      and component['adjust_spacing'] == False):
                    #print("#we hit y max / min and need to extend x")
                    new_y = y_og[-1]
                    component['modified_end_time'] = new_x
                    component['modified_end_emotional_score'] = new_y

                    if output_format == "svg":
                        surface.flush()   # flush the partial drawing, but do *not* finalize!
                    else:
                        surface.write_to_png(story_shape_path)

                    if story_data is None:
                        print("STORY DATA NONE -- 1")
                    
                    return story_data, "processing"
            
                elif component['spacing_adjustment_attempts'] < MAX_SPACING_ADJUSTMENT_ATTEMPTS and component['space_to_modify'] < component['spaces_in_arc_text'] and component["spacing_factor"] < 1000:
                    component['adjust_spacing'] = True

                    #adjust current multiplier
                    if component.get('status', "") == "expanding spacing":
                        print("spacing factor change")
                        component["spacing_factor"] = component["spacing_factor"] * 10
                    
                    try:
                        new_multiplier = max(0.8, component['spaces_width_multiplier'][component['space_to_modify']] - (0.1 / component["spacing_factor"]))
                        component['spaces_width_multiplier'][component['space_to_modify']] = new_multiplier
                    except:
                        new_multiplier = max(0.8, component['spaces_width_multiplier'][str(component['space_to_modify'])] - (0.1 / component["spacing_factor"]))
                        component['spaces_width_multiplier'][str(component['space_to_modify'])] = new_multiplier
                    
                    if new_multiplier == .8:
                        component['space_to_modify'] = component['space_to_modify'] + 1
                        print("NEW SPACE TO MODIFY: ", component['space_to_modify'])
                  

                    #adjust future mulitplier
                    #component['spaces_width_multiplier'][component['space_to_modify']] = component['spaces_width_multiplier'][component['space_to_modify']] - 0.01
                    component['spacing_adjustment_attempts'] = component['spacing_adjustment_attempts'] + 1

                    component['status'] = "reducing spacing"
                    

                    if output_format == "svg":
                        surface.flush()   # flush the partial drawing, but do *not* finalize!
                    else:
                        surface.write_to_png(story_shape_path)

                    if story_data is None:
                        print("STORY DATA NONE -- 2")
                    return story_data, "processing"
            
                else: #this means: "curve too short but can't change due to constraints"
                    #so we actually want less chars than we initially thought
                    if output_format == "svg":
                        surface.flush()   # flush the partial drawing, but do *not* finalize!
                    else:
                        surface.write_to_png(story_shape_path)

                    if component['arc_manual_override'] == True:
                        status = 'Manual Override'
                    # if component['adjust_spacing'] == True:
                    #     status = 'Close Enough!'
                    #     #print("CLOSE ENOUGH!")
                    else:
                        component['arc_text_valid'] = False
                        component['arc_text_valid_message'] = "curve too short but can't change due to constraints"
                        print("curve too short but can't change due to constraints")
                        #status = "curve too short but can't change due to constraints"
                        print("spacing attempts: ", component['spacing_adjustment_attempts'])
                        print("max_space_multipler: ", min_space_multipler)
                        print("spacing_factor: ", component['spacing_factor'])


                        if story_data is None:
                            print("STORY DATA NONE -- 3")

                        return story_data, "processing"


            #curve is too long so need to shorten it
            elif curve_length_status == "curve_too_long":

                #doing - 10 is super janky; the problem is that num a points is fixed so if you make arc length smaller but keep number of points the same then decreasing arc like becomes hard
                #an alternative apprach is instead of defining num of point you could define x_delta size and infer num of points
                original_arc_end_time_index_length = len(original_arc_end_time_values) - 3
                original_arc_end_emotional_score_index_length = len(original_arc_end_emotional_score_values) - 3
                
                #print(original_arc_end_time_values[original_arc_end_time_index_length], " : ", original_arc_end_emotional_score_values[original_arc_end_emotional_score_index_length])

                #check if last values of arc segments is the global max; if it's the global max then shouldn't touch unless the second to last is the same value then you can shorten it
                #normal mode can decrease everything 
                if (original_arc_end_time_values[-1] > old_min_x 
                    and original_arc_end_time_values[-1] < old_max_x
                    and original_arc_end_emotional_score_values[-1] > old_min_y
                    and original_arc_end_emotional_score_values[-1] < old_max_y
                    and len(component['arc_x_values']) > 1 and recursive_mode
                    and original_arc_end_time_index_length >= 0 
                    and original_arc_end_emotional_score_index_length >= 0
                    and component['adjust_spacing'] == False):
                    
                    component['modified_end_time'] = original_arc_end_time_values[original_arc_end_time_index_length]
                    component['modified_end_emotional_score'] = original_arc_end_emotional_score_values[original_arc_end_emotional_score_index_length]
                    
                    if output_format == "svg":
                        surface.flush()   # flush the partial drawing, but do *not* finalize!
                    else:
                        surface.write_to_png(story_shape_path)

                    if story_data is None:
                        print("STORY DATA NONE -- 4")

                    return story_data, "processing"
                
                #cant touch x -- maybe want to remove
                elif ((original_arc_end_time_values[-1] == old_min_x or original_arc_end_time_values[-1] == old_max_x)
                    and original_arc_end_emotional_score_values[-1] > old_min_y
                    and original_arc_end_emotional_score_values[-1] < old_max_y
                    and len(component['arc_x_values']) > 1 and recursive_mode 
                    and round(original_arc_end_emotional_score_values[-1],3) != round(original_arc_end_emotional_score_values[original_arc_end_emotional_score_index_length],3)
                    and original_arc_end_emotional_score_index_length >= 0
                    and component['adjust_spacing'] == False):

                    component['modified_end_time'] = original_arc_end_time_values[-1]
                    component['modified_end_emotional_score'] = original_arc_end_emotional_score_values[original_arc_end_emotional_score_index_length]
                    
                    if output_format == "svg":
                        surface.flush()   # flush the partial drawing, but do *not* finalize!
                    else:
                        surface.write_to_png(story_shape_path)

                    if story_data is None:
                        print("STORY DATA NONE -- 5")

                    return story_data, "processing"
                
                # #cant touch y
                # elif ((original_arc_end_emotional_score_values[-1] == old_min_y or original_arc_end_emotional_score_values[-1] == old_max_y)
                #     and original_arc_end_time_values[-1] > old_min_x 
                #     and original_arc_end_time_values[-1] < old_max_x
                #     and len(component['arc_x_values']) > 1 and recursive_mode
                #     and original_arc_end_time_index_length >= 0):

                #     #print("hey")
                #     print("modifying end time")
                #     component['modified_end_time'] = original_arc_end_time_values[original_arc_end_time_index_length]
                #     component['modified_end_emotional_score'] = original_arc_end_emotional_score_values[-1]

                #     if output_format == "svg":
                #         surface.flush()   # flush the partial drawing, but do *not* finalize!
                #     else:
                #         surface.write_to_png(story_shape_path)
                #     return story_data, "processing"

                elif component['spacing_adjustment_attempts'] < MAX_SPACING_ADJUSTMENT_ATTEMPTS and component['space_to_modify'] < component['spaces_in_arc_text'] and component["spacing_factor"] < 1000:
                    component['adjust_spacing'] = True
                    
                    if component.get('status', "") == "reducing spacing":
                        print("spacing factor change")
                        component["spacing_factor"] = component["spacing_factor"] * 10
                    
                    try:
                        new_multiplier = min(1.5, component['spaces_width_multiplier'][component['space_to_modify']] + (0.1 / component["spacing_factor"]))
                        component['spaces_width_multiplier'][component['space_to_modify']] = new_multiplier
                    except:
                        new_multiplier = min(1.5,component['spaces_width_multiplier'][str(component['space_to_modify'])] + (0.1 / component["spacing_factor"]))
                        component['spaces_width_multiplier'][str(component['space_to_modify'])] = new_multiplier
                    
                    if new_multiplier == 1.5:
                        component['space_to_modify'] = component['space_to_modify'] + 1
                        print("NEW SPACE TO MODIFY: ", component['space_to_modify'])
                    

                     #adjust next multiplier
                    #component['spaces_width_multiplier'][component['space_to_modify']] = component['spaces_width_multiplier'][component['space_to_modify']] + 0.01
                    component['spacing_adjustment_attempts'] = component['spacing_adjustment_attempts'] + 1
                    
                    component['status'] = "expanding spacing"

                    if output_format == "svg":
                        surface.flush()   # flush the partial drawing, but do *not* finalize!
                    else:
                        surface.write_to_png(story_shape_path)

                    if story_data is None:
                        print("STORY DATA NONE -- 6")

                    return story_data, "processing"

                else: # this means: curve too long but can't change due to constraints
                    # so we want more chars than we initially thought so let's up the number of chars
                    # so we need recalc descriptors and ask for longer 
                    if output_format == "svg":
                        surface.flush()   # flush the partial drawing, but do *not* finalize!
                    else:
                        surface.write_to_png(story_shape_path)

                    if component['arc_manual_override'] == True:
                        status = 'Manual Override'
                    # elif component['adjust_spacing'] == True:
                    #     status = 'Close Enough'
                        #print("CLOSE ENOUGH!")
                    else:
                        component['arc_text_valid'] = False
                        component['arc_text_valid_message'] = "curve too long but can't change due to constraints"
                        print("curve too long but can't change due to constraints")
                        print("spacing attempts: ", component['spacing_adjustment_attempts'])
                        print("max_space_multipler: ", max_space_multipler)
                        print("spacing_factor: ", component['spacing_factor'])

                        if story_data is None:
                            print("STORY DATA NONE -- 7")

                        return story_data, "processing"

            elif curve_length_status == "curve_correct_length":
                if output_format == "svg":
                    surface.flush()   # flush the partial drawing, but do *not* finalize!
                else:
                    surface.write_to_png(story_shape_path)
                status = 'All phrases fit exactly on the curve.'

            component['status'] = status


        # --- MODIFICATION: End main text group ---
        end_svg_group(cr, output_format)
        # -----------------------------------------

   #  --- Draw Title, Author, Protagonist ---
    # These variables will store the calculated positions needed later
    title_y = 0
    title_text_height = 0
    author_y = 0
    author_text_height = 0

    if has_title == "YES":
        # --- Draw Title ---
        final_layout_title = PangoCairo.create_layout(cr)
        final_layout_title.set_font_description(title_font_desc)
        final_layout_title.set_text(effective_title_text, -1)
       
        if title_font_underline:
            attr_list_title = Pango.AttrList(); underline_attr_title = Pango.attr_underline_new(Pango.Underline.SINGLE); attr_list_title.insert(underline_attr_title); final_layout_title.set_attributes(attr_list_title)

        title_text_width, title_text_height = final_layout_title.get_pixel_size() # Store measured height
        title_band_top = margin_y + drawable_height + gap_above_title
        title_x = margin_x
        title_y = title_band_top # Store title Y position

        begin_svg_group(cr, "title-group", output_format)
        cr.move_to(title_x, title_y)
        cr.set_source_rgb(*title_font_color) # Use RGB
        PangoCairo.show_layout(cr, final_layout_title)
        end_svg_group(cr, output_format)
        # --- End Draw Title ---

        # --- Draw Author ---
        if effective_author_text != "":
            final_layout_author = PangoCairo.create_layout(cr)
            final_layout_author.set_font_description(author_font_desc)
            final_layout_author.set_text(effective_author_text, -1)
            if author_font_underline:
                # ... (add underline attribute) ...
                 attr_list_author = Pango.AttrList(); underline_attr_author = Pango.attr_underline_new(Pango.Underline.SINGLE); attr_list_author.insert(underline_attr_author); final_layout_author.set_attributes(attr_list_author)


            author_text_width, author_text_height = final_layout_author.get_pixel_size() # Store measured height
            author_x = title_x
            author_y = title_y + title_text_height + author_padding # Store author Y

            begin_svg_group(cr, "author-group", output_format)
            cr.move_to(author_x, author_y)
            cr.set_source_rgb(*author_font_color) # Use RGB
            PangoCairo.show_layout(cr, final_layout_author)
            end_svg_group(cr, output_format)
        # --- End Draw Author ---

        # --- Draw Protagonist ---
        effective_protagonist_text = protagonist_text if protagonist_text else story_data.get('protagonist', '')
        if effective_protagonist_text:
            prot_layout = PangoCairo.create_layout(cr)
            prot_layout.set_font_description(protagonist_font_desc)
            prot_layout.set_text(effective_protagonist_text, -1)
            if protagonist_font_underline:
                # ... (add underline attribute) ...
                attr_list_prot = Pango.AttrList(); underline_attr_prot = Pango.attr_underline_new(Pango.Underline.SINGLE); attr_list_prot.insert(underline_attr_prot); prot_layout.set_attributes(attr_list_prot)

            prot_text_width, prot_text_height = prot_layout.get_pixel_size()

            # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
            # --- THE SINGLE PLACE TO CHANGE PROTAGONIST ALIGNMENT ---

            # Option 1: Align Protagonist Bottom with TITLE Bottom
            target_bottom_line = title_y + title_text_height

            # Option 2: Align Protagonist Bottom with AUTHOR Bottom
            # To use this: COMMENT OUT the line above and UNCOMMENT the 4 lines below.
            # Make sure 'has_author="YES"' and author text exists when uncommenting!
            # if effective_author_text != "":
            #     target_bottom_line = author_y + author_text_height
            # else: # Fallback if author isn't shown but you tried to align
            #     target_bottom_line = title_y + title_text_height

            # --- END OF ALIGNMENT CHANGE SECTION ---
            # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

            # Calculate protagonist Y based on the chosen target line
            prot_y = target_bottom_line - prot_text_height
            prot_x = margin_x + drawable_width - prot_text_width # Right aligned

            begin_svg_group(cr, "protagonist-group", output_format)
            cr.move_to(prot_x, prot_y)
            cr.set_source_rgb(*protagonist_font_color) # Use RGB
            PangoCairo.show_layout(cr, prot_layout)
            end_svg_group(cr, output_format)
        # --- End Draw Protagonist ---


        # --- MODIFICATION: End Title Group ---
       # --- End Title/Author/Protagonist Block ---



    # MAKE NOTES ON TOP AND BOTTOM OF CANVAS -- only applies when wrap_in_inches > 0
    cr.restore()  # <== restore out of that translation


    if wrap_in_inches > 0:

        if top_text == "":

            author = story_data.get('author','')
            year = story_data.get('year', '')
            if(author == '' and year == ''):
                top_text = ""
            elif(author == '' and year != ''):
                top_text = year 
            elif(author != '' and year == ''):
                top_text = author
            elif(author != '' and year != ''):
                top_text = author + ", " + year
            else:
                top_text = ""

      
        x_top_center = total_width_px / 2
        band_height_top = top_and_bottom_text_band * CURRENT_DPI  # 1.5" band
        band_start_top = design_offset_y - band_height_top  # upper edge of top band
        band_end_top   = design_offset_y                    # shape starts here

        y_top_center = band_start_top + (band_height_top / 2)
       

        place_text_centered(cr,
                            text=top_text,
                            font_size_px=top_text_font_size_for_300dpi,
                            font_face = top_text_font_style,
                            x_center=x_top_center,
                            y_center=y_top_center,
                            rotation_degrees=0,
                            color= (top_text_font_color))

        # 3) Place text on bottom edge, fully centered
        bottom_wrap_y = design_offset_y + design_height  # The shape ends here
        band_height_bottom = top_and_bottom_text_band * dpi                   # Another 1.5" band
        band_start_bottom = bottom_wrap_y
        band_end_bottom   = bottom_wrap_y + band_height_bottom

        x_bottom_center = total_width_px / 2
        y_bottom_center = band_start_bottom + (band_height_bottom / 2)


        if bottom_text == "":
            bottom_text = "THE SHAPES OF STORIES, LLC"
        place_text_centered(cr,
                            text=bottom_text,
                            font_size_px=bottom_text_font_size_for_300dpi,
                            font_face = bottom_text_font_style,
                            color = bottom_text_font_color,
                            x_center=x_bottom_center,
                            y_center=y_bottom_center,
                            rotation_degrees=0)


    
    # 7) Save final image
    if output_format == "svg":
        surface.finish()
    else:
        surface.write_to_png(story_shape_path)

    # 8) QUICK AUDIT (skip for SVG)
    if output_format == "png":
        try:
            margins = verify_safe_margin(
                path=story_shape_path,
                bg_rgb=tuple(int(c*255) for c in background_value),
                dpi=CURRENT_DPI,                    # ← match your real DPI
                margin_in=fixed_margin_in_inches,
                tolerance_px=0             # or 1–2 px if you prefer
            )
            print("✅ margin check:", margins, "px")
        except ValueError as e:
            print(e)
        # optionally: raise, or set status="error", etc.
    if story_data is None:
        print("STORY DATA NONE -- 8")
    return story_data, "completed"


def calculate_arc_length(arc_x_values, arc_y_values):
    segment_lengths = np.hypot(
        np.diff(arc_x_values), np.diff(arc_y_values)
    )
    total_length = np.sum(segment_lengths)
    return total_length

def get_average_char_width(pangocairo_context, font_desc, sample_text=None):
    layout = Pango.Layout.new(pangocairo_context)
    layout.set_font_description(font_desc)

    if sample_text is None or sample_text == "":
        sample_text = (
            "Nervous. First Day. Office. Challenges. Potential."
        )
    layout.set_text(sample_text, -1)
    total_width = layout.get_pixel_size()[0]
    num_chars = len(sample_text.replace(" ", ""))
    average_char_width = total_width / num_chars
    return average_char_width


def estimate_characters_fit(arc_length, average_char_width, average_rotation_angle=0, spacing=1.0):
    rotation_adjustment = 1 + (abs(math.sin(math.radians(average_rotation_angle))) * 0.1)
    adjusted_char_width = average_char_width * rotation_adjustment * spacing
    return int(arc_length / adjusted_char_width)

def calculate_average_rotation_angle(x_values, y_values):
    angles = []
    for idx in range(1, len(x_values)):
        dx = x_values[idx] - x_values[idx - 1]
        dy = y_values[idx] - y_values[idx - 1]
        angle = math.degrees(math.atan2(dy, dx))
        angles.append(angle)
    average_angle = sum(angles) / len(angles)
    return average_angle


def generate_descriptors(title, author, protagonist, component_description, story_data, desired_length, llm_provider, llm_model, config_path):
    
    existing_arc_texts = "\n".join(
        component.get('arc_text', '') 
        for component in story_data['story_components'] 
        if 'arc_text' in component
    )
    
    if existing_arc_texts:
        existing_arc_texts = f"Previous descriptions:\n{existing_arc_texts}"

    
    prompt_template = """ ## INSTRUCTIONS 
Your task is to identify and express the most significant moments from this segment of {author}'s "{title}". Create a series of precise phrases that capture {protagonist}'s key story beats, fitting exactly {desired_length} characters.

## STORY SEGMENT DESCRIPTION:
{component_description}

## REQUIREMENTS:
1. CONTENT:
    - USE ONLY elements directly from the provided STORY SEGMENT DESCRIPTION
    - FOCUS on the perspective of {protagonist} 
    - SELECT concrete actions, events, places, objects, people
    - PRIORITIZE the most significant moments and actions pertaining to {protagonist}'s story
    - NEVER mention {protagonist} by name

2. FORMAT: 
    - BE CONCISE, descriptors should consist of 1-4 word phrases
    - A single phrase is perfectly acceptable 
    - If multiple phrases, each ends with ". " except the last phrase, which ends with just "." and no space
    - CAPITALIZATION: Use Title Case (capitalize the first letter of every word, except minor words like "and," "of," "the," unless they are the first word of a phrase)
    
3. PHRASE CONSTRUCTION:
    - CAPTURE the progression of events that drive the story forward
    - Break compound actions into separate phrases
    - AVOID redundant information across phrases
    - Each phrase should capture a complete, meaningful story beat

4. PHRASE ORDERING: 
    - The order of the phrases MUST be in chronological order as events occur in STORY SEGMENT DESCRIPTION
    - Each phrase should flow naturally into the next to tell a coherent story of {protagonist} 

5. CONTINUITY:
    - Each story segment descriptors joins with other story segments to tell the full {protagonist}'s story
    - Descriptors should be distinct from previous story segment descriptors: {existing_arc_texts}

6. LENGTH: OUTPUT MUST BE EXACTLY {desired_length} CHARACTERS. NO MORE, NO LESS
    - Count EVERY character including spaces and periods
    - Count EVERY period and space between phrases
    - Example: "Green Light." is 12 characters
    
7. VERIFICATION:
    Step 1: Verify Narrative Quality
    - Do phrases capture the most important story moments?
    - Are events in correct chronological order?
    - Does each phrase advance the story?

    Step 2: Verify Technical Requirements
    - Count all characters (including spaces and periods)
    - Check format and capitalization
    - Confirm no protagonist name used
    - Verify source material accuracy

8. OUTPUT: Provide ONLY the descriptor text, exactly {desired_length} characters. No explanation. 


## EXAMPLES:

### EXAMPLE 1
Length Requirements: 12 characters
Author: F. Scott Fitzgerald
Title: The Great Gatsby
Protagonist: Jay Gatsby
Story Segment Description: "Gatsby stands alone in his garden, reaching out towards the green light across the bay, embodying his yearning for Daisy. His elaborate mansion and lavish parties serve as carefully orchestrated attempts to attract her attention, revealing both his hope and desperation. When he finally arranges to meet Nick, his neighbor and Daisy's cousin, Gatsby's carefully constructed facade begins to show cracks of vulnerability as he seeks a way to reconnect with his lost love"

Potential Phrases (with character counts including ending punctuation) -- note phrases shown are non-exhaustive and are just meant to provide examples of potential phrases
- "Alone in Garden." (16 characters)
- "Green Light."  (12 characters)
- "Yearning for Daisy." (20 characters)
- "Lost Love." (10 characters)

Selected Output (12 characters): "Green Light."


### EXAMPLE 2
Length Requirements: 37 characters
Author: Ernest Hemingway
Title: The Old Man and the Sea
Protagonist: Santiago
Story Segment Description: "Despite 84 days without a catch and being considered unlucky, Santiago maintains his dignity and optimism. His friendship with Manolin provides comfort and support, though the boy has been forced to work on another boat. His determination remains strong as he prepares for a new day of fishing, finding peace in his dreams of Africa and its lions."

Potential Phrases -- note phrases shown are non-exhaustive:
- "84 Days No Fish." (16 characters)
- "Unlucky." (8 characters)
- "Optimist." (9 characters)
- "Manolin Friendship." (19 characters)
- "Preps for Fishing." (18 characters)
- "Dreams of Africa." (16 characters)

Selected Output (37 characters): "84 Days. No Fish. Manolin Friendship."


### EXAMPLE 3
Length Requirements: 79 characters
Author: William Shakespeare
Title: Romeo and Juliet
Protagonist: Juliet
Story Segment Description: "Juliet awakens to find Romeo dead beside her, having poisoned himself in the belief she was dead. In her final moments, she experiences complete despair, attempting to die by kissing his poisoned lips before ultimately using his dagger to join him in death, unable to conceive of life without him."

Potential Phrases -- note phrases shown are non-exhaustive:
- "Awakens." (8 characters)
- "Romeo Dead." (11 characters)
- "Despair." (8 characters)
- "Kisses Poisoned Lips." (21 characters)
- "Suicide by Dagger." (18 characters)
- "Reunited with Love." (19 characters)

Selected Output (79 characters): "Awakens. Romeo Dead. Complete Despair. Kisses Poisoned Lips. Suicide by Dagger."

Notes for All Examples:
- Each phrase except the last ends with ". " (period + space = 2 chars). The last phrase ends with "." (period only = 1 char)
- Phrases appear in chronological order as events occur in Story Segment Description
- Character counts include the space after the period in ALL phrases

________

Respond with ONLY the descriptor text, exactly {desired_length} characters. No explanation.
"""
    
    prompt = PromptTemplate(
        input_variables=["desired_length", "author", "title", "protagonist", "component_description", "existing_arc_texts"],  # Define the expected inputs
        template=prompt_template
    )
    config = load_config(config_path=config_path)
    llm = get_llm(llm_provider, llm_model, config, max_tokens=500)

     # Instead of building an LLMChain, use the pipe operator:
    runnable = prompt | llm

    # Then invoke with the required inputs:
    output = runnable.invoke({
        "desired_length": desired_length,
        "author": author,
        "title": title,
        "protagonist": protagonist,
        "component_description":component_description,
        "existing_arc_texts":existing_arc_texts,
    })

    #print(output)
    # If the output is an object with a 'content' attribute, extract it.
    if hasattr(output, "content"):
        output_text = output.content
    else:
        output_text = output
    
    output_text = output_text.strip()
    return output_text

import numpy as np
import math
from shapely.geometry import Polygon
from shapely.affinity import rotate as shapely_rotate
import shapely.affinity
import re
from gi.repository import Pango, PangoCairo # Ensure these are imported at the top of your file


# Ensure these are imported at the top of your story_shape.py
import numpy as np
import math
from shapely.geometry import Polygon
from shapely.affinity import rotate as shapely_rotate
import shapely.affinity
import re
from gi.repository import Pango, PangoCairo

# ... (your other helper functions like get_average_char_width, pango_font_exists etc.)
# story_shape.py (helper function, can be near other Pango helpers)

# story_shape.py

# ... (other imports)

def get_standard_space_width(pangocairo_context, font_desc):
    """
    Gets the pixel width of a standard space character for the given font,
    without any dynamic char_spacing_factor or space_width_multiplier applied.
    """
    layout = Pango.Layout.new(pangocairo_context)
    layout.set_font_description(font_desc)
    layout.set_text(" ", -1)  # A single space character
    width, _ = layout.get_pixel_size()
    # It's possible for a font to have a zero-width space, handle defensively.
    return width if width > 0 else 1 # Return at least 1px to avoid division by zero later



#### THE OLD STORY FUNCTION CODE ###

import pandas as pd
import numpy as np
import json
import itertools
import math


def find_breakpoints(x, y, threshold = 1.0):
    step_points = []
    for i in range(1, len(y)):
        if abs(y[i] - y[i-1]) >= threshold:
            step_points.append(x[i-1])
    return step_points


def insert_points(x, y, num_insert_points, threshold=1.0):
    breakpoints = find_breakpoints(x, y, threshold)
    new_x, new_y = [], []

    for i in range(len(x)):
        new_x.append(x[i])
        new_y.append(y[i])

        if i < len(x) - 1 and x[i] in breakpoints:
            y_increment = (y[i+1] - y[i]) / (num_insert_points + 1)
            for j in range(1, num_insert_points + 1):
                new_x.append(x[i])
                new_y.append(y[i] + j * y_increment)

    return new_x, new_y


#scale plot points to numbers 1 - 10 for consistency across stories
def scale_plot_points(original_plot_points, new_min, new_max):
    old_min = np.min(original_plot_points)
    old_max = np.max(original_plot_points)
    scaled_plot_points = new_min + ((original_plot_points - old_min) / (old_max - old_min)) * (new_max - new_min)
    return scaled_plot_points


def scale_y_values(y_values, new_min, new_max):
    old_min = np.min(y_values)
    old_max = np.max(y_values)
    if old_max == old_min:
        # Avoid division by zero if all y_values are the same
        return np.full_like(y_values, new_min)
    scaled_values = ((y_values - old_min) / (old_max - old_min)) * (new_max - new_min) + new_min
    return scaled_values
   


def get_component_arc_function(x1, x2, y1, y2, arc, step_k=15, max_num_steps=3):

    def exponential_step_function(x):
        # 1) If out of range, return None
        if not (x1 <= x <= x2):
            return None
        
        # 2) Decide how many steps you want
        # num_steps = int(math.ceil(x2 - x1))
        # if num_steps < 1:
        #     num_steps = 1
        # elif num_steps > 3:
        #     num_steps = 3


        # distance = math.hypot(x2 - x1, y2 - y1)  # sqrt(dx^2 + dy^2)
        # # Then map distance to [1..3] steps, for example:
        # if distance < 1:
        #     num_steps = 1
        # elif distance < 3:
        #     num_steps = 2
        # else:
        #     num_steps = 3

        dx = abs(x2 - x1)
        dy = abs(y2 - y1)

        if dx == 0:
            # Avoid dividing by zero
            slope = float('inf')
        else:
            slope = dy / dx

        # Example rule:
        # - if slope is small (< ~ 0.5), only 1 step
        # - if slope is moderate, use 2 steps
        # - if slope is steep, use 3 steps

        if slope < 0.5:
            num_steps = 1
        elif slope < 3.0:
            num_steps = 2
        else:
            num_steps = max_num_steps
        
        
        # 3) We create the sub-intervals
        x_edges = np.linspace(x1, x2, num_steps + 1)  # e.g. [x1, x1+1, x1+2, ..., x2]
        # total change in y is (y2 - y1)
        dy = (y2 - y1) / num_steps
        
        # 4) Find which step i such that x_edges[i] <= x <= x_edges[i+1]
        # e.g. loop or use a quick search:
        for i in range(num_steps):
            start = x_edges[i]
            end   = x_edges[i+1]
            
            if start <= x <= end:
                # y_base is the bottom of step i
                y_base = y1 + i * dy
                
                # now define an exponential from y_base up to y_base + dy
                # choose a k (steepness)
                k = step_k  # or 10, or something user-chosen
                # map x into [0..1] for exponential
                alpha = (x - start) / (end - start)  # 0 to 1
                # standard increase formula:
                local_y = y_base + dy * (1 - math.exp(-k * alpha))
                return local_y
        
        # If x somehow equals x2 exactly, let's ensure we return y2
        return y2


    def s_curve_step_function(x):
        """
        Returns an S-curve-based step interpolation for the interval [x1, x2],
        subdivided into multiple 'step' segments. Each sub-interval uses a
        smoothstep function for a gentle transition, rather than a sharp jump.

        Args:
            x (float): The x-value at which we want the interpolated y.
            x1, x2 (float): The start and end x-values of the overall segment.
            y1, y2 (float): The start and end y-values at x1 and x2.
            max_num_steps (int): Maximum number of steps to use for steep slopes.
            step_k (float): Optional steepness factor for controlling how sharply
                            the step transitions occur.

        Returns:
            float or None:
                - The interpolated y-value if x is within [x1, x2].
                - None if x is outside that range.

        Behavior:
            1. Computes slope = (|y2 - y1| / |x2 - x1|).
            2. Decides how many sub-steps to create:
            - If slope < 0.5, use 1 step.
            - If slope < 3.0, use min(2, max_num_steps).
            - Else, use max_num_steps.
            3. Splits [x1, x2] into 'num_steps' sub-intervals (x_edges).
            4. For each sub-interval, uses a smoothstep-like function to
            ease from the sub-interval's base (y_base) to y_base + (dy).
            5. Returns y2 if x == x2 exactly (to handle any rounding issues).

        Example:
            Suppose (x1, y1) = (0, 0), (x2, y2) = (10, 5), and slope is moderate.
            We might get 2 steps:
                - Step 1 covers x in [0..5], step 2 covers x in [5..10].
                - Within each step, we do a smooth S-curve from y_base to y_base + dy.
        """

        # 1) If x is out of [x1, x2], return None.
        if not (min(x1, x2) <= x <= max(x1, x2)):
            return None

        # 2) Handle the edge case where x1 == x2.
        dx = x2 - x1
        if abs(dx) < 1e-12:  # effectively vertical line
            # If x1 == x2 and x is that same value, just return y1 (or y2).
            return y1

        # 3) Calculate slope and decide number of steps.
        dy_abs = abs(y2 - y1)
        slope = float('inf') if abs(dx) < 1e-12 else (dy_abs / abs(dx))

        if slope < 0.5:
            num_steps = 1
        elif slope < 3.0:
            #num_steps = min(2, max_num_steps)
            num_steps = 2
        else:
            num_steps = max_num_steps

        # 4) Subdivide the interval [x1, x2].
        x_edges = np.linspace(x1, x2, num_steps + 1)
        total_dy = (y2 - y1)
        dy_per_step = total_dy / num_steps

        # 5) Identify which sub-interval x falls into.
        for i in range(num_steps):
            start, end = x_edges[i], x_edges[i + 1]

            # Ensure start <= end for the loop logic, even if x2 < x1.
            if start > end:
                start, end = end, start

            if start <= x <= end:
                # Base y for this step
                y_base = y1 + i * dy_per_step

                # alpha in [0..1] within this sub-interval
                alpha = (x - x_edges[i]) / (x_edges[i + 1] - x_edges[i])

                # Option A: Standard smoothstep
                # local_y = y_base + dy_per_step * (alpha**2 * (3 - 2*alpha))

                # Option B: Use step_k to adjust steepness if desired.
                # The code below is a simple variation: alpha^(n) * ( (n+1) - n*alpha ).
                # Adjust n = step_k / 10.0 or pick your own formula.
                n = max(1.0, step_k / 10.0)  # avoid n=0
                smooth_factor = (alpha**n) * ((n + 1) - n * alpha)

                local_y = y_base + dy_per_step * smooth_factor
                return local_y

        # 6) If we got here, x might be exactly x2 (float rounding).
        return y2


    def smooth_step_function(x):
        if x1 <= x <= x2:
            #num_steps = int((x2) - (x1))
            num_steps = int(math.ceil(x2 - x1))
            #print(x2, " ", x1)
            if num_steps < 1:
                num_steps = 2  # Ensure at least one step
            elif num_steps > 3:
                num_steps = 3
            #num_steps = 2

            # Calculate the positions of the steps
            step_edges = np.linspace(x1, x2, num_steps + 1)
            step_height = (y2 - y1) / num_steps

            # Define smoothing width as a fraction of step width
            step_width = (x2 - x1) / num_steps
            smoothing_fraction = 0.5 # Adjust this value between 0 and 0.5
            smoothing_width = smoothing_fraction * step_width

            # Determine which step we're in
            for i in range(num_steps):
                start = step_edges[i]
                end = step_edges[i + 1]
                y_base = y1 + i * step_height

                # If we're within the smoothing region at the end of the step
                if end - smoothing_width <= x <= end:
                    t = (x - (end - smoothing_width)) / smoothing_width
                    # Smoothstep interpolation
                    transition = t**2 * (3 - 2 * t)
                    return y_base + step_height * transition
                # If we're within the flat part of the step
                elif start <= x < end - smoothing_width:
                    return y_base
            return y2  # In case x == x2
        else:
            return None

    def smooth_exponential_decrease_function(x):
        # Only define behavior in the interval [x1, x2]
        if x1 <= x <= x2:
            # We want the function to rapidly drop from y1 at x1 and approach y2 as x approaches x2.
            # Let's choose k so that at x2 we're close to y2, say within 1%:
            # exp(-k*(x2-x1)) = 0.01 -> -k*(x2-x1)=ln(0.01) -> k = -ln(0.01)/(x2-x1)
            # ln(0.01) ~ -4.60517, so k ≈ 4.6/(x2-x1).
            # You can adjust this factor (4.6) if you want a different "steepness".
            if x2 > x1:  
                k = 15 / (x2 - x1)
            else:
                # Avoid division by zero if times are equal
                k = 1.0

            return y2 + (y1 - y2)*math.exp(-k*(x - x1))
        else:
            return None

    def smooth_exponential_increase_function(x):
        # Similar logic but reversed to create a curve that starts low and rises up.
        if x1 <= x <= x2:
            if x2 > x1:
                #k = 4.6 / (x2 - x1)
                k = 15 / (x2 - x1)
            else:
                k = 1.0

            # For an "increase", you can simply flip the logic:
            # Start at y1 and approach y2 from below using a mirrored exponential shape:
            # y(x) = y1 + (y2 - y1)*(1 - exp(-k*(x - x1)))
            return y1 + (y2 - y1)*(1 - math.exp(-k*(x - x1)))
        else:
            return None
    
    def straight_decrease_function(x):
        if x1 <= x <= x2:
            # Parameters to adjust
            horizontal_fraction = 0.01  # Adjust as needed

            # Calculate key points
            total_interval = x2 - x1
            horizontal_end = x1 + horizontal_fraction * total_interval

            if x1 <= x < horizontal_end:
                # Initial horizontal segment at y1
                return y1
            elif horizontal_end <= x <= x2:
                # Immediate jump to y2
                return y2
            else:
                return None
        else:
            return None
 
    def straight_increase_function(x):
        if x1 <= x <= x2:
            horizontal_fraction = 0.01  # Adjust as needed
            total_interval = x2 - x1
            horizontal_end = x1 + horizontal_fraction * total_interval

            if x1 <= x < horizontal_end:
                return y1
            elif horizontal_end <= x <= x2:
                return y2
            else:
                return None
        else:
            return None

    def step_function(x):
        if x1 <= x <= x2:

            #num_steps = (x2 - x1)
            #num_steps = 2 #setting static number of steps
            #step_height = (y2 - y1) / num_steps
            #print("x1: ", x1, " x2: ", x2, " y1: ", y1, " y2: ", y2)
            #print("num_steps: ", num_steps, "  step_height: ", step_height)
            #steps_completed = int((x - x1) / ((x2 - x1) / num_steps)) # Calculate the number of steps from x1 to x
            
            num_steps = int(x2 - x1)
            if(num_steps < 1):
                num_steps = 1  # Static number of steps
            
            segment_width = (x2 - x1) / (num_steps + 1)
            steps_completed = int((x - x1) / segment_width)
            step_height = (y2 - y1) / num_steps
       
            return y1 + (steps_completed * step_height)
        else:
            return None
            
    def linear_function(x):
        if x1 <= x <= x2:
            return y1 + ((y2 - y1) / (x2 - x1)) * (x - x1)
        else:
            return None
    
    def concave_up_decreasing_function(x):
        if x1 <= x <= x2:
            a = (y1 - y2) / ((x1 - x2) * (x1 + x2 - 2*x2))
            b = y2 - a * (x2 - x2)**2
            return a * (x - x2)**2 + b
        else:
            return None
        
    def concave_down_decreasing_function(x):
        if x1 <= x <= x2:
            a = (y2 - y1) / ((x2 - x1) * (x2 + x1 - 2*x1))
            b = y1 - a * (x1 - x1)**2
            return a * (x - x1)**2 + b
        else:
            return None
        
    def concave_up_increasing_function(x):
        if x1 <= x <= x2:
            a = (y2 - y1) / ((x2 - x1) * (x2 + x1 - 2*x1))
            b = y1 - a * (x1 - x1)**2
            return a * (x - x1)**2 + b
        else:
            return None

    def concave_down_increasing_function(x):
        if x1 <= x <= x2:
            a = (y1 - y2) / ((x1 - x2) * (x1 + x2 - 2*x2))
            b = y2 - a * (x2 - x2)**2
            return a * (x - x2)**2 + b
        else:
            return None

    def test(x):
        
        xm = (x1 + x2) / 2
        ym = (y1 + y2) / 2
        
        if x1 <= x <= xm:
            # Concave down decreasing function up to the midpoint
            a = (ym - y1) / ((xm - x1)**2)
            return a * (x - xm)**2 + ym
        elif xm < x <= x2:
            # Concave up decreasing function from the midpoint to x2
            a = (ym - y2) / ((xm - x2)**2)
            return a * (x - xm)**2 + ym
        else:
            return None
            
    def curvy_down_up(x):
        
        xm = (x1 + x2) / 2
        ym = (y1 + y2) / 2
        a_down = (ym - y1) / ((xm - x1)**2)
        b_down = y1 - a_down * (x1 - x1)**2
        
        # Ensure the vertex of concave up is at (x2, y2)
        a_up = (ym - y2) / ((xm - x2)**2)
        b_up = y2 - a_up * (x2 - x2)**2
        
        if x1 <= x <= xm:
            return a_down * (x - x1)**2 + b_down
        elif xm < x <= x2:
            return a_up * (x - x2)**2 + b_up
        else:
            return None
    


   
    if x1 == x2:
        # x1 == x2, return a function that is only defined at x == x1
        def point_function(x):
            if x == x1:
                return y1
            else:
                return None
        return point_function
    else:
        # Existing code for other arcs
        if arc in['Step-by-Step Increase', 'Step-by-Step Decrease']:
            return exponential_step_function
            #return s_curve_step_function
        elif arc in ['Straight Increase']:
            return smooth_exponential_increase_function
        elif arc in ['Straight Decrease']:
            return smooth_exponential_decrease_function
        elif arc in ['Linear Increase','Linear Decrease','Gradual Increase', 'Gradual Decrease', 'Linear Flat']:
            #return linear_function #3/8/2025
            return curvy_down_up #replacing linear function with s-curve function because it avoid gaps in designs
        elif arc in ['Concave Down, Increase', 'Rapid-to-Gradual Increase']:
            return concave_down_increasing_function
        elif arc in ['Concave Down, Decrease', 'Gradual-to-Rapid Decrease']:
            return concave_down_decreasing_function
        elif arc in ['Concave Up, Increase', 'Gradual-to-Rapid Increase']:
            return concave_up_increasing_function
        elif arc in ['Concave Up, Decrease', 'Rapid-to-Gradual Decrease']:
            return concave_up_decreasing_function
        elif arc in ['Hyperbola Increase','Hyperbola Decrease', 'S-Curve Increase', 'S-Curve Decrease']:
            return curvy_down_up
        elif arc  == 'test':
            return test
        else:
            #print(arc)
            raise ValueError(f"{arc} Interpolation method not supported")
    

  
# Master function to evaluate the emotional score for any given plot point number
def get_story_arc(x, functions_list):
    for func in functions_list:
        result = func(x)
        if result is not None:
            return result
    return None  # Return None if x is outside the range of all functions


def transform_story_data(data, x_delta, step_k, max_num_steps ):
    # # Convert JSON to DataFrame
    # try:
    #     df = pd.json_normalize(
    #         data, 
    #         record_path=['story_components'], 
    #         meta=[
    #             'title', 
    #             'protagonist'
    #         ],
    #         record_prefix='story_component_'
    #     )
    # except Exception as e:
    #     print("Error:", e)
    #     print("NORMALIZE IS BREAKING!")
    #     return None

        # --- Start of transform_story_data ---
    if not isinstance(data, dict):
        print(f"transform_story_data FATAL: Input 'data' is not a dictionary. Type: {type(data)}")
        return None 
    
    if 'story_components' not in data:
        print(f"transform_story_data FATAL: 'story_components' key missing from input data. Keys: {list(data.keys())}")
        return None

    if not isinstance(data['story_components'], list):
        print(f"transform_story_data FATAL: 'story_components' is not a list. Type: {type(data['story_components'])}")
        return None

    components_for_df_creation = []
    for comp_idx, component_data_item in enumerate(data['story_components']):
        if not isinstance(component_data_item, dict):
            print(f"transform_story_data WARNING: story_component at index {comp_idx} is not a dict. Skipping.")
            continue 

        mod_end_time = component_data_item.get('modified_end_time')
        mod_emo_score = component_data_item.get('modified_end_emotional_score')
        arc_type = component_data_item.get('arc') 
        description = component_data_item.get('description', '#N/A') # Get description

        # All components (including the first placeholder) need time and score.
        if mod_end_time is None or mod_emo_score is None:
            print(f"transform_story_data WARNING: Essential time/score missing in component {comp_idx}. Skipping. Data: {component_data_item}")
            continue
        
        # If arc_type is None (e.g. for the first component if 'arc' key is missing), default to "#N/A"
        # This ensures the key 'story_component_arc' will exist for all rows going into the DataFrame.
        if arc_type is None:
            arc_type = "#N/A"

        essential_comp_info = {
            # Fields that will be directly used or selected later with these exact names
            'title': data.get('title', 'Unknown Title'), 
            'protagonist': data.get('protagonist', 'Unknown Protagonist'),
            'story_component_arc': arc_type, # Use the direct name
            'story_component_description': description, # Use the direct name

            # Fields that will be renamed later (or you can name them directly now)
            # Using 'modified_...' prefix initially, then renaming, is fine if you prefer that pattern.
            'story_component_modified_end_time': mod_end_time,
            'story_component_modified_end_emotional_score': mod_emo_score,
        }
        components_for_df_creation.append(essential_comp_info)

    if not components_for_df_creation or len(components_for_df_creation) < 2 :
        print(f"transform_story_data ERROR: Not enough valid components ({len(components_for_df_creation)}) to create DataFrame for arc calculation.")
        return None

    try:
        df = pd.DataFrame(components_for_df_creation)
    except Exception as e:
        print(f"transform_story_data ERROR: Creating DataFrame from components_for_df_creation failed: {e}")
        return None
    if not components_for_df_creation or len(components_for_df_creation) < 2 : # Need at least 2 points to form an arc
        print(f"transform_story_data ERROR: Not enough valid components ({len(components_for_df_creation)}) to create DataFrame for arc calculation.")
        return None

    try:
        df = pd.DataFrame(components_for_df_creation)
    except Exception as e:
        print(f"transform_story_data ERROR: Creating DataFrame from components_for_df_creation failed: {e}")
        return None


    # Print the column names for debugging
    #print("DataFrame columns:", df.columns.tolist())

    # Use 'story_component_modified_end_time' and 'story_component_modified_end_emotional_score' directly
    df['story_component_end_time'] = df['story_component_modified_end_time']
    df['story_component_end_emotional_score'] = df['story_component_modified_end_emotional_score']

    # Rename other columns as needed
    df = df.rename(columns={
        'story_component_description': 'story_component_description',
        'story_component_arc': 'story_component_arc'
    })

    # Select relevant columns
    df = df[['title', 'protagonist', 'story_component_end_time', 'story_component_end_emotional_score', 'story_component_arc', 'story_component_description']]
    df = df.sort_values(by='story_component_end_time', ascending=True)

    # Convert time values to x-values
    story_time_values = df['story_component_end_time'].tolist()
    x_original = np.array(story_time_values)
    x_scale = np.array(scale_plot_points(x_original, 1, 10))  # Scale x values so they are 1 - 10

    # Store pairs of x_original values and their scaled counterparts
    x_dict = dict(zip(x_original, x_scale))

    # Extract individual story components
    array_of_dicts = []
    for i in range(len(df) - 1):  # -1 because we are considering pairs of adjacent rows
        start_time = x_dict[df.loc[i, 'story_component_end_time']]
        end_time = x_dict[df.loc[i + 1, 'story_component_end_time']]
        start_emotional_score = df.loc[i, 'story_component_end_emotional_score']
        end_emotional_score = df.loc[i + 1, 'story_component_end_emotional_score']
        arc = df.loc[i + 1, 'story_component_arc']  # Using the arc of the second point

        dict_item = {
            'story_component_times': [start_time, end_time],
            'story_component_end_emotional_scores': [start_emotional_score, end_emotional_score],
            'arc': arc
        }
        array_of_dicts.append(dict_item)

    # Create a list to store the component story arcs
    story_arc_functions_list = []
    for item in array_of_dicts:
        story_component_times = item['story_component_times']
        story_component_end_emotional_scores = item['story_component_end_emotional_scores']
        story_component_arc = item['arc']

        # Create the function based on the specified interpolation
        component_arc_function = get_component_arc_function(
            story_component_times[0],
            story_component_times[1],
            story_component_end_emotional_scores[0],
            story_component_end_emotional_scores[1],
            story_component_arc,
            step_k,
            max_num_steps
        )
        story_arc_functions_list.append(component_arc_function)

    num_points = int((max(x_scale) - min(x_scale)) / x_delta)
    #print(num_points)
    x_values = np.linspace(min(x_scale), max(x_scale), num_points)  # 1000 points for smoothness

    # Ensure x_values includes all x1 and x2 values
    x1_x2_values = set()
    for item in array_of_dicts:
        x1_x2_values.update(item['story_component_times'])
    x_values = np.unique(np.concatenate([x_values, np.array(list(x1_x2_values))]))
    x_values.sort()

    y_values = np.array([get_story_arc(x, story_arc_functions_list) for x in x_values])  # Calculate corresponding y-values
    y_values = scale_y_values(y_values, -10, 10)

    # Process arcs for each story component
    story_component_index = 1
    for item in array_of_dicts:
        story_component_times = item['story_component_times']
        story_component_end_emotional_scores = item['story_component_end_emotional_scores']
        story_component_arc = item['arc']

        component_arc_function = get_component_arc_function(
            story_component_times[0],
            story_component_times[1],
            story_component_end_emotional_scores[0],
            story_component_end_emotional_scores[1],
            story_component_arc, 
            step_k,
            max_num_steps
        )
        result = np.array([get_story_arc(x, [component_arc_function]) for x in x_values])

        non_none_positions = np.where(result != None)[0]

        # **Add check for empty non_none_positions**
        if non_none_positions.size == 0:
            print(f"No valid positions for component at index {story_component_index}, function returns None for all x")
            story_component_index += 1
            continue  # Skip this component or handle accordingly

        arc_x_values = x_values[non_none_positions]
        arc_y_values = y_values[non_none_positions]

        
        #1/12/2024 -- testing to see if I can help produce smoother arcs
        # if(story_component_arc == 'Straight Increase' or story_component_arc == 'Straight Decrease'):
        #     pts = list(zip(arc_x_values, arc_y_values))
        #     smoothed_pts = chaikin_curve(pts, iterations=1)
        #     arc_x_values_smoothed, arc_y_values_smoothed = zip(*smoothed_pts)

        #     arc_x_values = np.array(arc_x_values_smoothed)
        #     arc_y_values = np.array(arc_y_values_smoothed)


        # Handle specific arcs if necessary
        # if story_component_arc in ['Straight Increase', 'Straight Decrease']:
        #     if non_none_positions.size > 1:
        #         prepend_indices = [non_none_positions[0] - 2, non_none_positions[0] - 1]
        #         # Ensure indices are within bounds
        #         prepend_indices = [idx for idx in prepend_indices if idx >= 0]
        #         if prepend_indices:
        #             prepend_x = x_values[prepend_indices]
        #             prepend_y = y_values[prepend_indices]
        #             arc_x_values = np.insert(arc_x_values, 0, prepend_x)
        #             arc_y_values = np.insert(arc_y_values, 0, prepend_y)
            
            # Decrease the number of values inserted
            # prepend_index = non_none_positions[0] - 1
            # # Ensure index is within bounds
            # if prepend_index >= 0:
            #     prepend_x = x_values[prepend_index]
            #     prepend_y = y_values[prepend_index]
            #     arc_x_values = np.insert(arc_x_values, 0, prepend_x)
            #     arc_y_values = np.insert(arc_y_values, 0, prepend_y)
            # else:
            #     print(f"Not enough positions to prepend for component at index {story_component_index}")

        data['story_components'][story_component_index]['arc_x_values'] = arc_x_values.tolist()
        data['story_components'][story_component_index]['arc_y_values'] = arc_y_values.tolist()

        story_component_index += 1

    data['x_values'] = x_values.tolist()
    data['y_values'] = y_values.tolist()

    return data


def place_text_centered(cr, text, font_size_px,
                       x_center, y_center,
                       rotation_degrees=0,
                       color=(0,0,0),
                       font_face="Sans"):
    """
    Draw 'text' so that its center is at (x_center, y_center).
    If rotation_degrees != 0, we rotate about that center point.
    """
    # 1) Create Pango layout to measure text
    layout = PangoCairo.create_layout(cr)
    font_desc = Pango.FontDescription(f"{font_face} {font_size_px}")
    layout.set_font_description(font_desc)
    layout.set_text(text, -1)
    text_width, text_height = layout.get_pixel_size()

    # 2) Compute top-left so the text is centered on (x_center,y_center)
    x_text = x_center - text_width/2
    y_text = y_center - text_height/2

    # 3) If rotating, we translate to center, rotate, then translate back
    cr.save()
    cr.set_source_rgb(*color)
    cr.move_to(x_text, y_text)
    if rotation_degrees != 0:
        cr.translate(x_center, y_center)
        cr.rotate(math.radians(rotation_degrees))
        cr.translate(-x_center, -y_center)

    # 4) Show the layout
    PangoCairo.show_layout(cr, layout)
    cr.restore()

def hex_to_rgb(hex_color):
    """
    Convert a hex color string to an RGB tuple normalized to [0, 1].

    Args:
        hex_color (str): Hex color string (e.g., '#001F3F').

    Returns:
        tuple: Normalized RGB tuple (e.g., (0.0, 0.12156862745098039, 0.24705882352941178)).
    """
    # Remove '#' if present
    hex_color = hex_color.lstrip('#')
    
    # Convert hex to integer values for RGB
    r = int(hex_color[0:2], 16) / 255.0  # Red
    g = int(hex_color[2:4], 16) / 255.0  # Green
    b = int(hex_color[4:6], 16) / 255.0  # Blue
    
    return (r, g, b)


def validate_descriptors(descriptors_text, protagonist, lower_bound, upper_bound):
    """
    Validates and fixes descriptor text against all requirements.
    
    Args:
        descriptors_text (str): The descriptor text to validate
        protagonist (str): Name of the protagonist to check against
        lower_bound (int): Minimum acceptable character count
        upper_bound (int): Maximum acceptable character count
    
    Returns:
        tuple: (bool, str) - (is_valid, error_message_or_fixed_text)
            If invalid: (False, error_message)
            If valid: (True, potentially_modified_text)
    """
    if not descriptors_text:
        return False, "Empty descriptor text"

    # 1. Length Check
    actual_length = len(descriptors_text)
    if not (lower_bound <= actual_length <= upper_bound):
        return False, f"Length {actual_length} outside bounds {lower_bound}-{upper_bound}"

    # 2. Protagonist Name Check
    if protagonist.lower() in descriptors_text.lower():
        return False, f"Contains protagonist name '{protagonist}'"

    # 3. Define minor words
    minor_words = {
        'a', 'an', 'the',
        'and', 'but', 'or', 'nor',
        'in', 'of', 'to', 'for', 'with', 'by', 'at', 'on', 'from',
    }

    # 4. Split into phrases and verify/fix each one
    # First split on period to get raw phrases
    raw_phrases = [p.strip() for p in descriptors_text.replace('. ', '.').split('.') if p.strip()]
    modified_phrases = []
    
    for phrase in raw_phrases:
        if not phrase:
            return False, "Contains empty phrase"
            
        words = phrase.split()
        if not words:
            return False, "Contains phrase without words"
        
        if len(words) > 5:
            return False, f"Phrase '{phrase}' has more than 5 words"
        if len(words) < 1:
            return False, f"Phrase '{phrase}' has no words"
            
        # Fix capitalization
        modified_words = []
        modified_words.append(words[0].capitalize())  # First word always capitalized
        
        for word in words[1:]:
            if word.lower() in minor_words:
                modified_words.append(word.lower())
            else:
                modified_words.append(word.capitalize())
        
        modified_phrases.append(' '.join(modified_words))

    # 5. Join phrases with proper formatting:
    # - All phrases except last end with ". "
    # - Last phrase ends with "."
    if len(modified_phrases) > 1:
        fixed_text = '. '.join(modified_phrases[:-1]) + '. ' + modified_phrases[-1] + '.'
    else:
        fixed_text = modified_phrases[0] + '.'

    # 6. Final length check after fixes
    if not (lower_bound <= len(fixed_text) <= upper_bound):
        return False, f"After fixes, length {len(fixed_text)} outside bounds {lower_bound}-{upper_bound}"

    return True, fixed_text

def pango_font_exists(font_name):
    """
    Checks whether the given font is available using Pango.
    Returns True if the font is found, False otherwise.
    """
    if not font_name:
        return True  # nothing to check if font_name is empty

    # Get the default font map from PangoCairo.
    font_map = PangoCairo.FontMap.get_default()
    families = font_map.list_families()

    # Iterate through the font families and see if any name matches (case-insensitive).
    for family in families:
        if font_name.lower() in family.get_name().lower():
            return True

    return False

# Utility to safely add attributes using tags
def begin_svg_group(cr, group_id, output_format):
    if output_format == "svg":
        # Using TAG_LINK is standard for adding attributes like id, class, href
        cr.tag_begin(cairo.TAG_LINK, f'id="{group_id}"')
        # You could add fill/stroke attributes here too if needed globally for the group
        # Example: cr.tag_begin(cairo.TAG_LINK, f'id="{group_id}" fill="white"')

def end_svg_group(cr, output_format):
    if output_format == "svg":
        cr.tag_end(cairo.TAG_LINK)
# --- End Helper ---


from PIL import Image
import numpy as np

def verify_safe_margin(
        path: str,
        bg_rgb: tuple,
        dpi: int = CURRENT_DPI,
        margin_in: float = 0.625,
        tolerance_px: int = 0   # allow tiny bleed if you like
    ):
    """
    Opens the finished image and checks that every edge has at least
    `margin_in` inches of background (± `tolerance_px`).

    Raises ValueError if any side is short; returns a dict if all good.
    """
    img = Image.open(path).convert("RGB")
    arr = np.asarray(img)

    # distance from solid background colour
    dist = np.linalg.norm(arr - np.array(bg_rgb), axis=2)
    content = dist > 15                    # tweak threshold if needed

    rows = np.where(content.any(1))[0]
    cols = np.where(content.any(0))[0]

    top    = rows.min()
    bottom = img.height - 1 - rows.max()
    left   = cols.min()
    right  = img.width  - 1 - cols.max()

    target = int(round(margin_in * dpi))

    margins = dict(top=top, right=right, bottom=bottom, left=left)
    short   = {k:v for k,v in margins.items()
               if v < (target - tolerance_px)}

    # if short:
    #     raise ValueError(
    #         f"🚨  Margin shortfall: wanted ≥{target}px, "
    #         f"but got {short}"
    #     )

    return margins



# Place this helper function somewhere accessible, e.g., near draw_text_on_curve
def get_standard_space_width(pangocairo_context, font_desc):
    """
    Gets the pixel width of a standard space character for the given font.
    """
    layout = Pango.Layout.new(pangocairo_context)
    layout.set_font_description(font_desc)
    layout.set_text(" ", -1)  # A single space character
    width, _ = layout.get_pixel_size()
    # It's possible for a font to have a zero-width space, handle defensively.
    return width if width > 0 else 1 # Return at least 1px to avoid division by zero later


def draw_text_on_curve(
        cr, 
        x_values_scaled, 
        y_values_scaled, 
        text, 
        pangocairo_context, 
        font_desc, 
        all_rendered_boxes, 
        margin_x, 
        margin_y, 
        design_width, 
        design_height,
        spaces_width_multiplier,
        adjust_spacing):
    
    total_curve_length = np.sum(np.hypot(np.diff(x_values_scaled), np.diff(y_values_scaled)))
    cumulative_curve_lengths = np.insert(np.cumsum(np.hypot(np.diff(x_values_scaled), np.diff(y_values_scaled))), 0, 0)

    idx_on_curve = 0
    distance_along_curve = 0

    def get_tangent_angle(x_vals, y_vals, idx):
        if idx == 0:
            dx = x_vals[1] - x_vals[0]
            dy = y_vals[1] - y_vals[0]
        elif idx == len(x_vals) - 1:
            dx = x_vals[-1] - x_vals[-2]
            dy = y_vals[-1] - y_vals[-2]
        else:
            dx = x_vals[idx + 1] - x_vals[idx - 1]
            dy = y_vals[idx + 1] - y_vals[idx - 1]
        angle = math.atan2(dy, dx)
        return angle

    import re
    phrases = re.findall(r'.+?(?:\. |$)', text)
    phrases = [phrase for phrase in phrases if phrase.strip()]

    char_positions = []
    rendered_boxes = []
    all_text_fits = True

    space_count = 0
    for phrase in phrases:
        temp_char_positions = []
        temp_rendered_boxes = []
        saved_idx_on_curve = idx_on_curve
        saved_distance_along_curve = distance_along_curve
        phrase_fits = True

        for char in phrase:
            layout = Pango.Layout.new(pangocairo_context)
            layout.set_font_description(font_desc)
            layout.set_text(char, -1)
            char_width, char_height = layout.get_pixel_size()

            if adjust_spacing == True and char == ' ':
                before_char_width = char_width
                #print("char_width before multiplier: ", char_width)
                try:
                    char_width = get_standard_space_width(pangocairo_context, font_desc) * spaces_width_multiplier[space_count]
                    #print("multiplier: ", spaces_width_multiplier[space_count])
                except:
                    char_width = get_standard_space_width(pangocairo_context, font_desc) * spaces_width_multiplier[str(space_count)]
                    #print("multiplier: ", spaces_width_multiplier[str(space_count)])
                
                after_char_width = char_width
                #print("char width after multiplier: ", char_width, " | diff: ", (after_char_width - before_char_width) )
                


                space_count = space_count + 1

            while idx_on_curve < len(cumulative_curve_lengths) - 1:
                segment_start_distance = cumulative_curve_lengths[idx_on_curve]
                segment_end_distance = cumulative_curve_lengths[idx_on_curve + 1]
                segment_distance = segment_end_distance - segment_start_distance

                if segment_distance == 0:
                    idx_on_curve += 1
                    continue

                ratio = (distance_along_curve - segment_start_distance) / segment_distance

                if ratio < 0 or ratio > 1:
                    idx_on_curve += 1
                    continue

                x = x_values_scaled[idx_on_curve] + ratio * (x_values_scaled[idx_on_curve + 1] - x_values_scaled[idx_on_curve])
                y = y_values_scaled[idx_on_curve] + ratio * (y_values_scaled[idx_on_curve + 1] - y_values_scaled[idx_on_curve])
                angle = get_tangent_angle(x_values_scaled, y_values_scaled, idx_on_curve)

                box = Polygon([
                    (-char_width / 2, -char_height / 2),
                    (char_width / 2, -char_height / 2),
                    (char_width / 2, char_height / 2),
                    (-char_width / 2, char_height / 2)
                ])

                rotated_box = shapely_rotate(box, angle * (180 / math.pi), origin=(0, 0), use_radians=False)
                translated_box = shapely.affinity.translate(rotated_box, xoff=x, yoff=y)

                #CAUSED ALOT OF ISSUES !!!!!!!!!
                # ── NEW: bounce the char if it crosses the 0.625‑in safety zone ──
                # if (translated_box.bounds[0] < margin_x or                 # left
                #     translated_box.bounds[2] > design_width  - margin_x or # right
                #     translated_box.bounds[1] < margin_y or                 # top
                #     translated_box.bounds[3] > design_height - margin_y
                #     ):  # bottom
                #     distance_along_curve += 1      # scoot 1 px along path
                #     continue                       # try again at new spot
                # ───────────────────────────────────────────────

                # Check overlap
                for other_box in rendered_boxes + all_rendered_boxes:
                    if translated_box.intersects(other_box):
                        distance_along_curve += 1
                        break
                else:
                    temp_char_positions.append((x, y, angle, char, char_width, char_height))
                    temp_rendered_boxes.append(translated_box)
                    rendered_boxes.append(translated_box)
                    all_rendered_boxes.append(translated_box)

                    distance_along_curve += char_width
                    break
            else:
                # No space left on the curve
                phrase_fits = False
                break

        if phrase_fits:
            char_positions.extend(temp_char_positions)
        else:
            # rollback
            idx_on_curve = saved_idx_on_curve
            distance_along_curve = saved_distance_along_curve
            rendered_boxes = rendered_boxes[:len(rendered_boxes) - len(temp_rendered_boxes)]
            all_rendered_boxes = all_rendered_boxes[:len(all_rendered_boxes) - len(temp_rendered_boxes)]
            all_text_fits = False
            break

    # Render characters
    for x, y, angle, char, char_width, char_height in char_positions:
        cr.save()
        cr.translate(x, y)
        cr.rotate(angle)

        layout = PangoCairo.create_layout(cr)
        layout.set_font_description(font_desc)
        layout.set_text(char, -1)
        cr.translate(-char_width / 2, -char_height / 2) 
        PangoCairo.show_layout(cr, layout)
        cr.restore()

    average_char_width = get_average_char_width(pangocairo_context, font_desc, text)
    remaining_curve_length = total_curve_length - distance_along_curve

    if not all_text_fits:
        print("curve_too_short | spacing, ", adjust_spacing)
        curve_length_status = "curve_too_short"
    elif remaining_curve_length > average_char_width: #and adjust_spacing == False:
        print("curve_too_long | spacing, ", adjust_spacing, " | remaining length: ", (remaining_curve_length - average_char_width), " | average_char_width", average_char_width)
        curve_length_status = "curve_too_long"
    # elif remaining_curve_length > (average_char_width * 2) and adjust_spacing == True:
    #     print("spacing true | remaining length: ", (remaining_curve_length - (average_char_width * 2)))
    #     curve_length_status = "curve_too_long"
    else:
        curve_length_status = "curve_correct_length"

    return curve_length_status



















                  















def _layout_single_phrase_on_curve(
    cr, x_values_scaled_np, y_values_scaled_np, phrase_text,
    pangocairo_context, font_desc,
    initial_distance_on_curve, initial_idx_on_curve,
    total_curve_length, cumulative_curve_lengths,
    base_char_spacing_factor, space_width_multiplier, standard_space_width,
    existing_rendered_boxes, # Boxes from previous phrases IN THE SAME ARC or previous arcs
    margin_x, margin_y, design_width, design_height,
    arc_drawable_bottom_y # Pre-calculated effective bottom boundary
):
    """
    Attempts to lay out a single phrase on the curve.

    Returns:
        tuple: (
            bool_success,
            final_distance_on_curve,
            final_idx_on_curve,
            list_of_char_render_info,  # [(x, y, angle, char, char_w_measured, char_h_measured), ...]
            list_of_new_boxes_for_this_phrase
        )
    bool_success is True if the entire phrase was laid out without going off curve
                 or causing collisions/boundary issues.
    """
    
    # --- This part is largely from your existing draw_text_on_curve's inner loop ---
    # --- with modifications for space_width_multiplier ---
    
    # Helper to get tangent angle (reuse your existing one)
    def get_tangent_angle(x_vals, y_vals, idx):
        # (Your existing get_tangent_angle implementation)
        if len(x_vals) < 2: return 0
        if idx == 0:
            dx = x_vals[1] - x_vals[0]
            dy = y_vals[1] - y_vals[0]
        elif idx >= len(x_vals) - 1:
            dx = x_vals[-1] - x_vals[-2]
            dy = y_vals[-1] - y_vals[-2]
        else:
            dx = x_vals[idx + 1] - x_vals[idx - 1]
            dy = y_vals[idx + 1] - y_vals[idx - 1]
        if dx == 0 and dy == 0:
            if idx > 0: return get_tangent_angle(x_vals, y_vals, idx - 1)
            return 0
        return math.atan2(dy, dx)

    distance_on_curve = initial_distance_on_curve
    idx_on_curve = initial_idx_on_curve
    
    char_render_info_list = []
    new_boxes_for_this_phrase = []

    for char_idx, char_glyph in enumerate(phrase_text):
        layout = Pango.Layout.new(pangocairo_context)
        layout.set_font_description(font_desc)
        layout.set_text(char_glyph, -1)
        char_width_measured, char_height = layout.get_pixel_size()

        char_width_effective = char_width_measured * base_char_spacing_factor
        if char_glyph == ' ':
            # Use the standard_space_width scaled by multipliers
            char_width_effective = standard_space_width * space_width_multiplier * base_char_spacing_factor
            # Ensure space has some width, even if char_width_measured for space was 0 (unlikely for normal space)
            if char_width_effective <=0 : char_width_effective = base_char_spacing_factor # minimal width


        # --- Find position for this character (your existing robust logic) ---
        char_placed_successfully = False
        # Temp store for nudging if collision/boundary issues
        original_distance_on_curve_for_char = distance_on_curve 
        
        # Retry loop for nudging on collision/boundary
        max_nudges = 5 # Limit nudges to prevent infinite loops
        for nudge_attempt in range(max_nudges + 1):
            current_distance_on_curve_for_placement = original_distance_on_curve_for_char + nudge_attempt * 1.0 # Nudge 1px

            # Ensure we don't fall off the curve before even placing the char center
            if current_distance_on_curve_for_placement + (char_width_effective / 2.0) > total_curve_length:
                return False, distance_on_curve, idx_on_curve, char_render_info_list, new_boxes_for_this_phrase
            
            temp_idx_on_curve = idx_on_curve # Use a temp var for finding segment for this char
            
            char_found_segment = False
            while temp_idx_on_curve < len(cumulative_curve_lengths) - 1:
                segment_start_distance = cumulative_curve_lengths[temp_idx_on_curve]
                segment_end_distance = cumulative_curve_lengths[temp_idx_on_curve + 1]
                segment_length = segment_end_distance - segment_start_distance

                if segment_length <= 1e-6:
                    temp_idx_on_curve += 1
                    continue

                target_center_distance_on_curve = current_distance_on_curve_for_placement + (char_width_effective / 2.0)

                if target_center_distance_on_curve > segment_end_distance and temp_idx_on_curve < len(cumulative_curve_lengths) - 2:
                    temp_idx_on_curve += 1
                    continue
                
                distance_into_segment = target_center_distance_on_curve - segment_start_distance
                ratio = distance_into_segment / segment_length if segment_length > 1e-6 else 0.0


                if not (0 <= ratio <= 1.0):
                    if target_center_distance_on_curve > total_curve_length:
                        return False, distance_on_curve, idx_on_curve, char_render_info_list, new_boxes_for_this_phrase # Off curve
                    if ratio > 1.0 and temp_idx_on_curve < len(cumulative_curve_lengths) - 2:
                        temp_idx_on_curve += 1
                        continue
                    # Cannot place char in this segment or remaining curve under current conditions
                    break # Break from while temp_idx_on_curve loop, will lead to nudge or phrase fail


                x = x_values_scaled_np[temp_idx_on_curve] + ratio * (x_values_scaled_np[temp_idx_on_curve + 1] - x_values_scaled_np[temp_idx_on_curve])
                y = y_values_scaled_np[temp_idx_on_curve] + ratio * (y_values_scaled_np[temp_idx_on_curve + 1] - y_values_scaled_np[temp_idx_on_curve])
                angle = get_tangent_angle(x_values_scaled_np, y_values_scaled_np, temp_idx_on_curve)
                
                char_found_segment = True # Found a potential segment

                # Bounding box for collision
                half_w = char_width_measured / 2.0
                half_h = char_height / 2.0
                box = Polygon([(-half_w, -half_h), (half_w, -half_h), (half_w, half_h), (-half_w, half_h)])
                rotated_box = shapely_rotate(box, math.degrees(angle), origin=(0, 0), use_radians=False)
                translated_box = shapely.affinity.translate(rotated_box, xoff=x, yoff=y)

                # Boundary check
                b = translated_box.bounds
                if (b[0] < margin_x or b[2] > (design_width - margin_x) or
                    b[1] < margin_y or b[3] > arc_drawable_bottom_y):
                    # Out of bounds, this nudge attempt failed for this character
                    char_found_segment = False # Mark as not properly placed
                    break # Break from while temp_idx_on_curve, will try next nudge_attempt

                # Collision check
                collision = False
                for other_box in existing_rendered_boxes + new_boxes_for_this_phrase: # Check against ALL so far
                    if translated_box.intersects(other_box):
                        collision = True
                        break
                
                if collision:
                    # Collision, this nudge attempt failed for this character
                    char_found_segment = False # Mark as not properly placed
                    break # Break from while temp_idx_on_curve, will try next nudge_attempt

                # If no collision and in bounds for this nudge:
                char_render_info_list.append((x, y, angle, char_glyph, char_width_measured, char_height))
                new_boxes_for_this_phrase.append(translated_box)
                
                # IMPORTANT: Update main distance_on_curve and idx_on_curve only if successful
                distance_on_curve = current_distance_on_curve_for_placement + char_width_effective 
                idx_on_curve = temp_idx_on_curve # Update the main index on curve
                char_placed_successfully = True
                break # Break from while temp_idx_on_curve loop (found segment and placed)
            # End of: while temp_idx_on_curve < len(cumulative_curve_lengths) - 1

            if char_placed_successfully:
                break # Break from nudge_attempt loop for this character
            
            if not char_found_segment and not char_placed_successfully: 
                # This means even after checking segments, no valid placement was found for the current nudge.
                # If it was the last nudge, this char fails.
                if nudge_attempt == max_nudges:
                    return False, initial_distance_on_curve, initial_idx_on_curve, char_render_info_list, new_boxes_for_this_phrase

        # End of: for nudge_attempt in range(max_nudges + 1)

        if not char_placed_successfully:
            # All nudges failed for this character, so the phrase fails
            return False, initial_distance_on_curve, initial_idx_on_curve, char_render_info_list, new_boxes_for_this_phrase
    # End of: for char_idx, char_glyph in enumerate(phrase_text)

    return True, distance_on_curve, idx_on_curve, char_render_info_list, new_boxes_for_this_phrase

# ==============================================================================
#  CONTENTS FROM: create_poster.py
# ==============================================================================

# poster_creator.py
import math
import os
from PIL import Image, ImageDraw, ImageFont
import platform


DEFAULT_DPI = 300

def get_default_font():
    # ... (no changes)
    system = platform.system()
    if system == "Windows":
        font_paths = [
            os.path.join(os.environ.get("SystemRoot", "C:\\Windows"), "Fonts", "Arial.ttf"),
            os.path.join(os.environ.get("SystemRoot", "C:\\Windows"), "Fonts", "TIMES.TTF"),
            os.path.join(os.environ.get("SystemRoot", "C:\\Windows"), "Fonts", "Verdana.ttf"),
        ]
    elif system == "Darwin": # macOS
        font_paths = [
            "/System/Library/Fonts/Helvetica.ttc", "/Library/Fonts/Arial.ttf",
            "/System/Library/Fonts/Supplemental/Arial.ttf", "/Library/Fonts/Times New Roman.ttf",
            "/System/Library/Fonts/Supplemental/Times New Roman.ttf",
        ]
    else: # Linux/other
        font_paths = [
            "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
            "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
            "/usr/share/fonts/truetype/msttcorefonts/arial.ttf",
            "/usr/share/fonts/truetype/ubuntu/Ubuntu-R.ttf",
        ]
    for font_path in font_paths:
        if os.path.exists(font_path): return font_path
    print("Warning: Could not find a default system font.")
    try:
        font = ImageFont.load_default()
        if font: print("Using Pillow's limited default font."); return None
    except IOError: print("Error: Pillow's default font also failed to load.")
    return "FONT_ERROR"

def parse_color(color_input):
    # ... (no changes)
    if isinstance(color_input, str):
        if color_input.startswith('#'):
            hex_color = color_input.lstrip('#')
            if len(hex_color) == 3: hex_color = "".join([c * 2 for c in hex_color])
            if len(hex_color) != 6: raise ValueError("Invalid hex format.")
            return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        raise ValueError("Invalid hex string format.")
    elif isinstance(color_input, tuple) and len(color_input) == 3:
        if all(0 <= c <= 1 for c in color_input): return tuple(int(c * 255) for c in color_input)
        if all(0 <= c <= 255 for c in color_input): return tuple(int(c) for c in color_input)
        raise ValueError("RGB tuple values out of range.")
    raise TypeError("Color must be hex string or RGB tuple.")

def calculate_cell_content_size( # KEEP THIS CORRECTED VERSION
    poster_width_in, poster_height_in, dpi, margin_in, spacing_in,
    base_rows, base_cols, cell_row_span, cell_col_span
):
    # ... (Keep the version that correctly calculates total block size including internal spacing)
    if not all(arg > 0 for arg in [poster_width_in, poster_height_in, dpi, base_rows, base_cols, cell_row_span, cell_col_span]): return None
    if margin_in < 0 or spacing_in < 0: return None
    poster_width_px, poster_height_px = poster_width_in * dpi, poster_height_in * dpi
    margin_px, spacing_px_val = margin_in * dpi, spacing_in * dpi # renamed spacing_px to avoid conflict
    grid_area_width = poster_width_px - 2 * margin_px
    grid_area_height = poster_height_px - 2 * margin_px # This is initial, will be adjusted by title/subtitle
    if grid_area_width <= 0 or grid_area_height <= 0: return None
    total_h_spacing = max(0, (base_cols - 1)) * spacing_px_val
    total_v_spacing = max(0, (base_rows - 1)) * spacing_px_val
    effective_grid_width = grid_area_width - total_h_spacing
    effective_grid_height = grid_area_height - total_v_spacing # This refers to sum of base content heights
    if effective_grid_width <= 0 or effective_grid_height <= 0: return None
    base_content_width_float = effective_grid_width / base_cols
    base_content_height_float = effective_grid_height / base_rows
    if base_content_width_float <= 0 or base_content_height_float <= 0: return None
    cell_total_block_width_px = (cell_col_span * base_content_width_float) + max(0, (cell_col_span - 1)) * spacing_px_val
    cell_total_block_height_px = (cell_row_span * base_content_height_float) + max(0, (cell_row_span - 1)) * spacing_px_val
    return (int(round(cell_total_block_width_px)), int(round(cell_total_block_height_px)))



def create_layout_preview(
    poster_width_in,
    poster_height_in,
    output_path,
    base_rows,
    base_cols,
    grid_template,
    dpi=72, # Typically lower DPI for previews
    margin_in=0.75,
    spacing_in=0.5,
    background_color='#EFEFEF', # Preview-specific background
    # --- Text Block Options (mirroring create_poster) ---
    poster_title="",
    poster_title_font_path=None,
    poster_title_font_size_pt=36,
    poster_title_font_color='#000000',
    poster_subtitle="",
    poster_subtitle_font_path=None,
    poster_subtitle_font_size_pt=24,
    poster_subtitle_font_color='#000000',
    text_block_v_align='top',
    text_edge_padding_in=0.2,
    space_between_texts_in=0.05,
    space_text_grid_in=0.2,
    # --- Preview Specific Appearance ---
    preview_cell_fill_color='#D0D0FF',
    preview_cell_outline_color='#333333',
    preview_text_color='#000000', # For annotations inside cells
    preview_annotation_font_path=None,
    preview_annotation_font_size_pt=10,
    preview_text_padding_px=5
):
    # --- Basic Validations ---
    if not grid_template: print("Error (Preview): grid_template is empty."); return
    if not text_block_v_align in ['top', 'bottom']:
        print("Error (Preview): text_block_v_align must be 'top' or 'bottom'. Defaulting to 'top'.")
        text_block_v_align = 'top'
    # ... (other validations) ...

    # --- Convert Inches to Pixels ---
    poster_width_px = int(poster_width_in * dpi)
    poster_height_px = int(poster_height_in * dpi)
    margin_px = int(margin_in * dpi)
    spacing_px_grid = int(spacing_in * dpi)
    text_edge_padding_px = int(text_edge_padding_in * dpi)
    space_between_texts_px = int(space_between_texts_in * dpi)
    space_text_grid_px = int(space_text_grid_in * dpi)

    try:
        bg_color_rgb = parse_color(background_color)
        cell_fill_rgb = parse_color(preview_cell_fill_color)
        cell_outline_rgb = parse_color(preview_cell_outline_color)
        annotation_text_color_rgb = parse_color(preview_text_color)
    except ValueError as e: print(f"Error (Preview) parsing color: {e}"); return

    # --- Load Fonts & Calculate Text Element Dimensions ---
    title_font, subtitle_font, annotation_draw_font = None, None, None
    title_color_rgb, subtitle_color_rgb = None, None
    rendered_title_width, rendered_title_height = 0, 0
    rendered_subtitle_width, rendered_subtitle_height = 0, 0

    # Title Font
    if poster_title:
        try: title_color_rgb = parse_color(poster_title_font_color)
        except ValueError: poster_title = ""
        if poster_title:
            font_path = poster_title_font_path or get_default_font()
            if font_path != "FONT_ERROR":
                font_size = max(1, int(poster_title_font_size_pt * dpi / 72))
                try:
                    title_font = ImageFont.truetype(font_path, font_size) if font_path else ImageFont.load_default(size=font_size)
                    temp_draw = ImageDraw.Draw(Image.new("RGB",(1,1)))
                    try: bbox = temp_draw.textbbox((0,0), poster_title, font=title_font, anchor="lt")
                    except TypeError: bbox = temp_draw.textbbox((0,0), poster_title, font=title_font)
                    rendered_title_width, rendered_title_height = bbox[2]-bbox[0], bbox[3]-bbox[1]
                except Exception: poster_title = "" # Failed to load/measure
            else: poster_title = ""
    
    # Subtitle Font
    if poster_subtitle:
        try: subtitle_color_rgb = parse_color(poster_subtitle_font_color)
        except ValueError: poster_subtitle = ""
        if poster_subtitle:
            font_path = poster_subtitle_font_path or get_default_font()
            if font_path != "FONT_ERROR":
                font_size = max(1, int(poster_subtitle_font_size_pt * dpi / 72))
                try:
                    subtitle_font = ImageFont.truetype(font_path, font_size) if font_path else ImageFont.load_default(size=font_size)
                    temp_draw = ImageDraw.Draw(Image.new("RGB",(1,1)))
                    try: bbox = temp_draw.textbbox((0,0), poster_subtitle, font=subtitle_font, anchor="lt")
                    except TypeError: bbox = temp_draw.textbbox((0,0), poster_subtitle, font=subtitle_font)
                    rendered_subtitle_width, rendered_subtitle_height = bbox[2]-bbox[0], bbox[3]-bbox[1]
                except Exception: poster_subtitle = ""
            else: poster_subtitle = ""

    # Annotation Font (for inside cells)
    ann_font_path = preview_annotation_font_path or get_default_font()
    ann_font_size_px = max(1, int(preview_annotation_font_size_pt * dpi / 72))
    if ann_font_path != "FONT_ERROR":
        try: annotation_draw_font = ImageFont.truetype(ann_font_path, ann_font_size_px) if ann_font_path else ImageFont.load_default(size=ann_font_size_px)
        except: annotation_draw_font = ImageFont.load_default() # Fallback
    else: annotation_draw_font = ImageFont.load_default()


    # --- Calculate Total Height of the Text Block ---
    total_text_block_height_px = 0
    if poster_title and title_font: total_text_block_height_px += rendered_title_height
    if poster_subtitle and subtitle_font:
        if total_text_block_height_px > 0: total_text_block_height_px += space_between_texts_px
        total_text_block_height_px += rendered_subtitle_height
    
    # --- Determine Grid Area Boundaries ---
    grid_area_top_y = margin_px
    grid_area_bottom_y = poster_height_px - margin_px
    if total_text_block_height_px > 0:
        if text_block_v_align == 'top':
            grid_area_top_y = text_edge_padding_px + total_text_block_height_px + space_text_grid_px
            grid_area_top_y = max(margin_px, grid_area_top_y)
        elif text_block_v_align == 'bottom':
            grid_area_bottom_y = poster_height_px - (text_edge_padding_px + total_text_block_height_px + space_text_grid_px)
            grid_area_bottom_y = min(poster_height_px - margin_px, grid_area_bottom_y)

    # --- Calculate Grid Area Dimensions ---
    grid_area_width_px = poster_width_px - 2 * margin_px
    grid_area_height_px = grid_area_bottom_y - grid_area_top_y
    if grid_area_width_px <= 0 or grid_area_height_px <= 0:
        print("Error (Preview): No space left for grid."); # Draw text only if possible
        # ... (optional: draw text on blank canvas if grid fails) ...
        return

    # --- Calculate Base Cell Dimensions for the Grid (these are the crucial content sizes) ---
    total_h_spacing_grid = max(0, (base_cols - 1)) * spacing_px_grid
    total_v_spacing_grid = max(0, (base_rows - 1)) * spacing_px_grid
    effective_grid_width = grid_area_width_px - total_h_spacing_grid
    effective_grid_height = grid_area_height_px - total_v_spacing_grid

    if effective_grid_width <=0 or effective_grid_height <=0: print("Error (Preview): Effective grid area non-positive."); return
    # THIS IS THE BASE CONTENT SIZE OF A 1x1 CELL IN THE *ACTUAL* AVAILABLE GRID SPACE
    base_content_width_for_cells = effective_grid_width / base_cols
    base_content_height_for_cells = effective_grid_height / base_rows
    if base_content_width_for_cells <= 0 or base_content_height_for_cells <= 0: print("Error (Preview): Base content size non-positive."); return

    print(f"\n--- Preview: Calculated Cell Content Dimensions (at {dpi} DPI for preview) ---")
    print(f"Based on available grid area: {grid_area_width_px}x{grid_area_height_px}px at ({margin_px},{grid_area_top_y})")
    print(f"A 1x1 cell's base content area would be: {base_content_width_for_cells:.2f} x {base_content_height_for_cells:.2f} px")

    # --- Create Canvas & Draw Object ---
    preview_img = Image.new('RGB', (poster_width_px, poster_height_px), bg_color_rgb)
    draw = ImageDraw.Draw(preview_img)

    # --- Draw Text Elements ---
    y_cursor = 0
    if text_block_v_align == 'top':
        y_cursor = text_edge_padding_px
        if poster_title and title_font:
            draw.text(((poster_width_px - rendered_title_width) / 2, y_cursor), poster_title, fill=title_color_rgb, font=title_font)
            y_cursor += rendered_title_height
            if poster_subtitle and subtitle_font: y_cursor += space_between_texts_px
        if poster_subtitle and subtitle_font:
            draw.text(((poster_width_px - rendered_subtitle_width) / 2, y_cursor), poster_subtitle, fill=subtitle_color_rgb, font=subtitle_font)
    elif text_block_v_align == 'bottom':
        bottom_text_start_y = poster_height_px - text_edge_padding_px
        if poster_subtitle and subtitle_font:
            bottom_text_start_y -= rendered_subtitle_height
            draw.text(((poster_width_px - rendered_subtitle_width) / 2, bottom_text_start_y), poster_subtitle, fill=subtitle_color_rgb, font=subtitle_font)
            if poster_title and title_font: bottom_text_start_y -= (space_between_texts_px + rendered_title_height)
        if poster_title and title_font: # Handles only title, or title above subtitle
             # If subtitle was drawn, bottom_text_start_y is already adjusted. If not, adjust now.
             if not (poster_subtitle and subtitle_font): bottom_text_start_y -= rendered_title_height
             draw.text(((poster_width_px - rendered_title_width) / 2, bottom_text_start_y), poster_title, fill=title_color_rgb, font=title_font)

    # --- Draw Grid Cells and Annotations ---
    for i, cell_template_item in enumerate(grid_template):
        br, bc = cell_template_item['base_row'], cell_template_item['base_col']
        rs, cs = cell_template_item['row_span'], cell_template_item['col_span']
        content_idx = cell_template_item['content_index']

        # Dimensions of the visual block for this cell in the preview (includes internal spacing)
        preview_cell_block_width = (cs * base_content_width_for_cells) + max(0, (cs - 1)) * spacing_px_grid
        preview_cell_block_height = (rs * base_content_height_for_cells) + max(0, (rs - 1)) * spacing_px_grid
        
        # ACTUAL CONTENT size for this cell (this is what your PNG should be for create_poster)
        actual_content_width_for_image = int(round(preview_cell_block_width))
        actual_content_height_for_image = int(round(preview_cell_block_height))

        # Position of the cell block within the grid area
        block_x_start_in_grid = bc * (base_content_width_for_cells + spacing_px_grid)
        block_y_start_in_grid = br * (base_content_height_for_cells + spacing_px_grid)
        
        # Absolute position on the poster
        block_x_start_abs = margin_px + block_x_start_in_grid
        block_y_start_abs = grid_area_top_y + block_y_start_in_grid

        if actual_content_width_for_image <=0 or actual_content_height_for_image <= 0: continue

        draw.rectangle(
            [block_x_start_abs, block_y_start_abs,
             block_x_start_abs + actual_content_width_for_image, # Use actual content size for rect
             block_y_start_abs + actual_content_height_for_image],
            fill=cell_fill_rgb, outline=cell_outline_rgb, width=max(1, dpi // 100) # Thinner outline for preview
        )
        
        # Calculate dimensions in inches for annotation
        # This uses the DPI that was passed to create_layout_preview
        content_width_in_for_ann = actual_content_width_for_image / dpi
        content_height_in_for_ann = actual_content_height_for_image / dpi

        annotation_text_lines = [
            f"Cell: {i} (CI: {content_idx})",
            f"Span: {rs}x{cs}",
            f"Size for PNG:",
            f"{actual_content_width_for_image}x{actual_content_height_for_image}px (at {dpi} DPI)",
            f"~{content_width_in_for_ann:.2f}x{content_height_in_for_ann:.2f} in" # NEW LINE
        ]
        # Also update the console print statement if you want inches there too
        print(f"  - Cell {i} (CI: {content_idx}, Span {rs}x{cs}): PNG Target = "
              f"{actual_content_width_for_image}x{actual_content_height_for_image}px "
              f"(~{content_width_in_for_ann:.2f}x{content_height_in_for_ann:.2f} inches at {dpi} DPI)")
        
        # ... (your existing annotation text drawing logic, using annotation_draw_font and annotation_text_color_rgb)
        current_y_ann = block_y_start_abs + preview_text_padding_px
        line_h_approx = ann_font_size_px * 1.2 
        for line_idx, line_text in enumerate(annotation_text_lines):
            if current_y_ann + line_h_approx > block_y_start_abs + actual_content_height_for_image - preview_text_padding_px and line_idx > 0:
                draw.text((block_x_start_abs + preview_text_padding_px, current_y_ann), "...", fill=annotation_text_color_rgb, font=annotation_draw_font); break
            try:
                # Simplified text drawing for preview
                draw.text((block_x_start_abs + preview_text_padding_px, current_y_ann), line_text, fill=annotation_text_color_rgb, font=annotation_draw_font)
                # Estimate line height for next line
                current_y_ann += ann_font_size_px * 1.2 # Simpler advance
            except Exception: break 

    # --- Save Preview Image ---
    try:
        preview_img.save(output_path)
        print(f"\nLayout preview saved to {output_path}")
    except Exception as e: print(f"Error (Preview) saving image: {e}")
    finally: preview_img.close()

def create_poster(
    story_shape_paths,
    poster_width_in,
    poster_height_in,
    output_path,
    base_rows,
    base_cols,
    grid_template,
    dpi=DEFAULT_DPI,
    margin_in=0.75,         # General margin around the grid area
    spacing_in=0.5,         # Spacing BETWEEN grid cells
    background_color='#FFFFFF',
    # --- Text Block Options ---
    poster_title="",
    poster_title_font_path=None,
    poster_title_font_size_pt=36,
    poster_title_font_color='#000000',
    poster_subtitle="",
    poster_subtitle_font_path=None,
    poster_subtitle_font_size_pt=24,
    poster_subtitle_font_color='#000000',
    text_block_v_align='top',    # 'top', 'bottom' (center is more complex for dynamic grid)
    text_edge_padding_in=0.2,    # Padding from poster top/bottom edge to the text block
    space_between_texts_in=0.05, # Space between title and subtitle
    space_text_grid_in=0.2       # Space between the entire text block and the grid
):
    # --- Basic Validations ---
    if not grid_template: print("Error: grid_template is empty."); return
    if not text_block_v_align in ['top', 'bottom']:
        print("Error: text_block_v_align must be 'top' or 'bottom'. Defaulting to 'top'.")
        text_block_v_align = 'top'
    # ... (keep your other initial validations for dimensions, dpi, story_paths etc.)

    # --- Convert Inches to Pixels ---
    poster_width_px = int(poster_width_in * dpi)
    poster_height_px = int(poster_height_in * dpi)
    margin_px = int(margin_in * dpi) # This is the margin for the grid area primarily
    spacing_px_grid = int(spacing_in * dpi)
    
    text_edge_padding_px = int(text_edge_padding_in * dpi)
    space_between_texts_px = int(space_between_texts_in * dpi)
    space_text_grid_px = int(space_text_grid_in * dpi)

    try: bg_color_rgb = parse_color(background_color)
    except ValueError as e: print(f"Error parsing background color: {e}"); return

    # --- Load Fonts & Calculate Text Element Dimensions ---
    title_font, subtitle_font = None, None
    title_color_rgb, subtitle_color_rgb = None, None
    rendered_title_width, rendered_title_height = 0, 0
    rendered_subtitle_width, rendered_subtitle_height = 0, 0

    # Title
    if poster_title:
        try: title_color_rgb = parse_color(poster_title_font_color)
        except ValueError as e: print(f"Error parsing title color: {e}"); poster_title = ""
        if poster_title:
            font_path = poster_title_font_path or get_default_font()
            if font_path != "FONT_ERROR":
                font_size = max(1, int(poster_title_font_size_pt * dpi / 72))
                try:
                    title_font = ImageFont.truetype(font_path, font_size) if font_path else ImageFont.load_default(size=font_size)
                    # Use a temporary draw object to measure text
                    temp_draw = ImageDraw.Draw(Image.new("RGB",(1,1)))
                    try: bbox = temp_draw.textbbox((0,0), poster_title, font=title_font, anchor="lt")
                    except TypeError: bbox = temp_draw.textbbox((0,0), poster_title, font=title_font)
                    rendered_title_width = bbox[2] - bbox[0]
                    rendered_title_height = bbox[3] - bbox[1]
                except Exception as e: print(f"Error loading/measuring title font: {e}"); poster_title = ""
            else: poster_title = ""

    # Subtitle
    if poster_subtitle:
        try: subtitle_color_rgb = parse_color(poster_subtitle_font_color)
        except ValueError as e: print(f"Error parsing subtitle color: {e}"); poster_subtitle = ""
        if poster_subtitle:
            font_path = poster_subtitle_font_path or get_default_font()
            if font_path != "FONT_ERROR":
                font_size = max(1, int(poster_subtitle_font_size_pt * dpi / 72))
                try:
                    subtitle_font = ImageFont.truetype(font_path, font_size) if font_path else ImageFont.load_default(size=font_size)
                    temp_draw = ImageDraw.Draw(Image.new("RGB",(1,1)))
                    try: bbox = temp_draw.textbbox((0,0), poster_subtitle, font=subtitle_font, anchor="lt")
                    except TypeError: bbox = temp_draw.textbbox((0,0), poster_subtitle, font=subtitle_font)
                    rendered_subtitle_width = bbox[2] - bbox[0]
                    rendered_subtitle_height = bbox[3] - bbox[1]
                except Exception as e: print(f"Error loading/measuring subtitle font: {e}"); poster_subtitle = ""
            else: poster_subtitle = ""

    # --- Calculate Total Height of the Text Block ---
    total_text_block_height_px = 0
    if poster_title and title_font:
        total_text_block_height_px += rendered_title_height
    if poster_subtitle and subtitle_font:
        if total_text_block_height_px > 0: # If title also exists, add space between
            total_text_block_height_px += space_between_texts_px
        total_text_block_height_px += rendered_subtitle_height
    
    # --- Determine Grid Area Boundaries based on Text Alignment ---
    grid_area_top_y = margin_px
    grid_area_bottom_y = poster_height_px - margin_px

    if total_text_block_height_px > 0: # Only adjust if there's text
        if text_block_v_align == 'top':
            grid_area_top_y = text_edge_padding_px + total_text_block_height_px + space_text_grid_px
            # Ensure grid doesn't start below the general top margin if text block is small
            grid_area_top_y = max(margin_px, grid_area_top_y) 
        elif text_block_v_align == 'bottom':
            grid_area_bottom_y = poster_height_px - (text_edge_padding_px + total_text_block_height_px + space_text_grid_px)
            # Ensure grid doesn't end above the general bottom margin if text block is small
            grid_area_bottom_y = min(poster_height_px - margin_px, grid_area_bottom_y)

    # --- Calculate Grid Area Dimensions ---
    grid_area_width_px = poster_width_px - 2 * margin_px # Horizontal margins for grid
    grid_area_height_px = grid_area_bottom_y - grid_area_top_y

    if grid_area_width_px <= 0 or grid_area_height_px <= 0:
        print("Error: No space left for grid. Check text sizes, paddings, margins, or poster dimensions.")
        # Optionally, save poster with just text if any text was processed
        # ... (code to draw text only if grid fails) ...
        return

    # --- Calculate Base Cell Dimensions for the Grid ---
    total_h_spacing_grid = max(0, (base_cols - 1)) * spacing_px_grid
    total_v_spacing_grid = max(0, (base_rows - 1)) * spacing_px_grid
    effective_grid_width = grid_area_width_px - total_h_spacing_grid
    effective_grid_height = grid_area_height_px - total_v_spacing_grid

    if effective_grid_width <=0 or effective_grid_height <=0: print("Error: Effective grid area non-positive."); return
    base_content_width = effective_grid_width / base_cols
    base_content_height = effective_grid_height / base_rows
    if base_content_width <= 0 or base_content_height <= 0: print("Error: Base content size non-positive."); return

    # --- Create Canvas & Draw Object ---
    poster_img = Image.new('RGB', (poster_width_px, poster_height_px), bg_color_rgb)
    draw = ImageDraw.Draw(poster_img)

    # --- Draw Text Elements ---
    y_cursor = 0
    if text_block_v_align == 'top':
        y_cursor = text_edge_padding_px
        if poster_title and title_font:
            draw.text(((poster_width_px - rendered_title_width) / 2, y_cursor), poster_title, fill=title_color_rgb, font=title_font)
            y_cursor += rendered_title_height
            if poster_subtitle and subtitle_font: y_cursor += space_between_texts_px
        if poster_subtitle and subtitle_font:
            draw.text(((poster_width_px - rendered_subtitle_width) / 2, y_cursor), poster_subtitle, fill=subtitle_color_rgb, font=subtitle_font)
            y_cursor += rendered_subtitle_height
    
    elif text_block_v_align == 'bottom':
        # Calculate starting y for the bottom-most text element (subtitle or title)
        bottom_text_start_y = poster_height_px - text_edge_padding_px
        if poster_subtitle and subtitle_font:
            bottom_text_start_y -= rendered_subtitle_height # y is top of text, so subtract height
            draw.text(((poster_width_px - rendered_subtitle_width) / 2, bottom_text_start_y), poster_subtitle, fill=subtitle_color_rgb, font=subtitle_font)
            if poster_title and title_font: # If title is above it
                bottom_text_start_y -= (space_between_texts_px + rendered_title_height)
                draw.text(((poster_width_px - rendered_title_width) / 2, bottom_text_start_y), poster_title, fill=title_color_rgb, font=title_font)
        elif poster_title and title_font: # Only title at the bottom
             bottom_text_start_y -= rendered_title_height
             draw.text(((poster_width_px - rendered_title_width) / 2, bottom_text_start_y), poster_title, fill=title_color_rgb, font=title_font)

    # --- Process Grid Template: Load, Resize, Paste Images ---
    for cell_template_item in grid_template:
        content_idx = cell_template_item['content_index']
        img_path = story_shape_paths[content_idx] if content_idx < len(story_shape_paths) else None
        br, bc = cell_template_item['base_row'], cell_template_item['base_col']
        rs, cs = cell_template_item['row_span'], cell_template_item['col_span']

        image_target_block_width = (cs * base_content_width) + max(0, (cs - 1)) * spacing_px_grid
        image_target_block_height = (rs * base_content_height) + max(0, (rs - 1)) * spacing_px_grid
        
        block_x_start_in_grid = bc * (base_content_width + spacing_px_grid)
        block_y_start_in_grid = br * (base_content_height + spacing_px_grid)
        
        block_x_start_abs = margin_px + block_x_start_in_grid # Relative to poster edge (left margin)
        block_y_start_abs = grid_area_top_y + block_y_start_in_grid # Relative to poster edge (top of grid area)

        if not img_path or not os.path.isfile(img_path):
            # ... (placeholder drawing - keep your existing logic) ...
            draw.rectangle([block_x_start_abs, block_y_start_abs, block_x_start_abs + image_target_block_width, block_y_start_abs + image_target_block_height], outline="red", width=2)
            # Simplified placeholder text
            try: temp_font = ImageFont.load_default(size=15)
            except: temp_font = ImageFont.load_default()
            draw.text((block_x_start_abs + 5, block_y_start_abs + 5), f"Missing {content_idx}", fill="red", font=temp_font)
            continue
        try:
            img = Image.open(img_path)
            img_w_orig, img_h_orig = img.size
            if img_w_orig == 0 or img_h_orig == 0: continue
            
            ratio = min(image_target_block_width / img_w_orig, image_target_block_height / img_h_orig)
            new_w = max(1, int(img_w_orig * ratio))
            new_h = max(1, int(img_h_orig * ratio))
            img_resized = img.resize((new_w, new_h), Image.Resampling.LANCZOS)

            paste_x = int(block_x_start_abs + (image_target_block_width - new_w) / 2)
            paste_y = int(block_y_start_abs + (image_target_block_height - new_h) / 2)

            if img_resized.mode == 'RGBA':
                poster_img.paste(img_resized, (paste_x, paste_y), img_resized)
            else:
                poster_img.paste(img_resized, (paste_x, paste_y))
            img.close()
        except Exception as e:
            print(f"Error processing image {img_path}: {e}")
            # ... (error placeholder drawing - keep your existing logic) ...
            draw.rectangle([block_x_start_abs, block_y_start_abs, block_x_start_abs + image_target_block_width, block_y_start_abs + image_target_block_height], outline="orange", width=2)
            try: temp_font = ImageFont.load_default(size=15)
            except: temp_font = ImageFont.load_default()
            draw.text((block_x_start_abs + 5, block_y_start_abs + 5), f"Error {content_idx}", fill="orange", font=temp_font)


    # --- Save Poster ---
    try:
        poster_img.save(output_path)
        print(f"Poster saved successfully to {output_path}")
    except Exception as e: print(f"Error saving poster: {e}")
    finally: poster_img.close()

# --- MAIN EXECUTION BLOCK ---
if __name__ == "__main__":
    # Step 1: Define Poster General Parameters
    poster_output_folder = "./generated_posters/"
    os.makedirs(poster_output_folder, exist_ok=True)
    dummy_image_folder = os.path.join(poster_output_folder, "dummy_story_shapes")
    os.makedirs(dummy_image_folder, exist_ok=True)

    poster_w_inches = 18 
    poster_h_inches = 24 
    print_dpi = 300
    preview_dpi = 300 

    poster_general_margin_in = 1.0 # General margin for grid from poster edges
    grid_cell_spacing_in = 0.5  # Spacing between grid cells
    
    # --- Text Element Configuration ---
    main_title_text = "Ernest Hemingway"
    title_font_path_config = None 
    title_font_size_config = 100 # Test with large font
    title_color_config = '#222222'

    #subtitle_text_config = "A Deep Dive into Narrative Structures"
    subtitle_text_config = "The Shapes of Stories" # Test with no subtitle
    subtitle_font_path_config = None
    subtitle_font_size_config = 40
    subtitle_color_config = '#444444'
    
    text_alignment = 'top' # 'top' or 'bottom'
    padding_from_edge_in = 0.5      # Padding from poster edge to text block
    padding_between_texts_in = 0.1  # Padding between title and subtitle
    padding_text_to_grid_in = 0.5   # Padding between text block and grid

    # Step 2: Choose a Layout Template
    chosen_template_name = "stories4_4x1_grid" 
    # chosen_template_name = "stories4_hero_left_three_stacked_right"

    if chosen_template_name not in poster_layout_templates:
        print(f"Error: Template '{chosen_template_name}' not found."); exit()
    
    selected_layout = poster_layout_templates[chosen_template_name]
    print(f"\n--- Using Template: {chosen_template_name} ({selected_layout['description']}) ---")

    num_expected_stories = selected_layout["num_stories"]
    base_r_template = selected_layout["base_rows"]
    base_c_template = selected_layout["base_cols"]
    grid_def_template = selected_layout["grid_template"]
    print(f"Expects {num_expected_stories} stories. Base grid: {base_r_template}x{base_c_template}.")


    print(f"\n--- Generating Layout Preview (DPI: {preview_dpi}) ---")
    preview_filename = f"PREVIEW_{chosen_template_name}_{poster_w_inches}x{poster_h_inches}_text-{text_alignment}_DPI{preview_dpi}.png"
    preview_output_file = os.path.join(poster_output_folder, preview_filename)

    create_layout_preview(
        poster_width_in=poster_w_inches, poster_height_in=poster_h_inches,
        output_path=preview_output_file,
        base_rows=base_r_template, base_cols=base_c_template,
        grid_template=grid_def_template,
        dpi=preview_dpi, # Use the preview DPI here
        margin_in=poster_general_margin_in, 
        spacing_in=grid_cell_spacing_in,
        background_color='#E0E0E0', 
        # Text Block
        poster_title=main_title_text,
        poster_title_font_path=title_font_path_config, 
        poster_title_font_size_pt=title_font_size_config,
        poster_title_font_color=title_color_config, 
        poster_subtitle=subtitle_text_config,
        poster_subtitle_font_path=subtitle_font_path_config,
        poster_subtitle_font_size_pt=subtitle_font_size_config,
        poster_subtitle_font_color=subtitle_color_config,
        text_block_v_align=text_alignment,
        text_edge_padding_in=padding_from_edge_in,
        space_between_texts_in=padding_between_texts_in,
        space_text_grid_in=padding_text_to_grid_in,
        # Preview specific appearance
        preview_cell_fill_color='#C8C8FA', # Slightly different fill
        preview_annotation_font_size_pt=9 # Smaller for more text
    )
    
    # The print statements inside create_layout_preview will now output the
    # dimensions your PNGs should be if you were targeting the *preview_dpi_main*.
    # To get sizes for your *print_dpi* (e.g., 300), you would ideally run create_layout_preview
    # once with dpi=300 (and save it to a different filename, or just note the output).
    # Or, you can manually scale the output from the preview_dpi run.
    # Example: If preview at 72 DPI says 100x100px, for 300 DPI it's (100 * 300/72) x (100 * 300/72)

    print("\n--- To get PNG sizes for PRINT, re-run preview with print_dpi or scale the above. ---")

    # Step 4: Calculate Required Story Shape Sizes & Prepare Dummies
    # This step becomes more complex if we want dummy sizes to be perfectly accurate
    # before create_poster runs, as create_poster now calculates the final grid area.
    # For now, we'll use calculate_cell_content_size with initial poster dimensions,
    # understanding that create_poster will handle the true final sizing and placement.
    # The dummy images are mainly for having *something* to pass to create_poster.
    # print("\n--- Calculating Initial Target Sizes for Dummy Story Shapes (Print DPI) ---")
    # required_sizes = {} 
    # for i, cell_def in enumerate(grid_def_template):
    #     idx, rs, cs = cell_def['content_index'], cell_def['row_span'], cell_def['col_span']
    #     size = calculate_cell_content_size(
    #         poster_w_inches, poster_h_inches, print_dpi, poster_general_margin_in, 
    #         grid_cell_spacing_in, base_r_template, base_c_template, rs, cs
    #     )
    #     required_sizes[idx] = size if size else (50,50) # Fallback
    #     # if size: print(f"  - Dummy for idx {idx} (Cell {i}, Span {rs}x{cs}): ~{size[0]}x{size[1]}px")

    # story_files = [None] * num_expected_stories
    # print("\n--- Preparing/Checking Dummy Story Shape Image Paths ---")
    # for i in range(num_expected_stories):
    #     s = required_sizes.get(i, (50,50))
    #     dw, dh = max(1,s[0]), max(1,s[1]) # Ensure positive
    #     name = f"dummy_idx{i}_{dw}x{dh}.png"
    #     path = os.path.join(dummy_image_folder, name)
    #     if not os.path.exists(path):
    #         try:
    #             img = Image.new('RGB', (dw, dh), (210,210,230))
    #             dr = ImageDraw.Draw(img)
    #             try: f = ImageFont.load_default(size=max(10,int(min(dw,dh)/8)))
    #             except: f = ImageFont.load_default()
    #             txt = f"idx {i}\n{dw}x{dh}"
    #             try:
    #                 bb = dr.textbbox((0,0),txt,font=f,align="center")
    #                 dr.text(((dw-(bb[2]-bb[0]))/2, (dh-(bb[3]-bb[1]))/2), txt, (0,0,0), f, align="center")
    #             except: dr.text((5,5),txt,(0,0,0),f)
    #             img.save(path)
    #         except Exception as e: print(f"Err dummy {i}: {e}"); path=None
    #     story_files[i] = path


    story_files = [
        "/Users/johnmikedidonato/Projects/TheShapesOfStories/data/story_shapes/title-the-sun-also-rises_protagonist-jake-barnes_product-print_size-16x4.64_line-type-char_char_background-color-#C17F59_font-color-#1B2B3A_border-color-#7C4B2A_font-Futura_title-display-yes.png",
        "/Users/johnmikedidonato/Projects/TheShapesOfStories/data/story_shapes/title-the-old-man-and-the-sea_protagonist-santiago_product-print_size-16x4.64_line-type-char_char_background-color-#1B3F8B_font-color-#F0F4F5_border-color-#45776B_font-Lora_title-display-yes.png",
        "/Users/johnmikedidonato/Projects/TheShapesOfStories/data/story_shapes/title-a-farewell-to-arms_protagonist-frederic-henry_product-print_size-16x4.64_line-type-char_char_background-color-#4A5D4C_font-color-#FFFFFF_border-color-#8B0000_font-Futura_title-display-yes.png",
        "/Users/johnmikedidonato/Projects/TheShapesOfStories/data/story_shapes/title-for-whom-the-bell-tolls_protagonist-robert-jordan_product-print_size-16x4.64_line-type-char_char_background-color-#994636_font-color-#CAD2C5_border-color-#2D2424_font-Bitter_title-display-yes.png"
    ]
    
    # Step 7: Create Actual Poster
    print("\n--- Generating Actual Poster ---")
    filename = f"POSTER_{chosen_template_name}_{poster_w_inches}x{poster_h_inches}_text-{text_alignment}.png"
    output_file_path = os.path.join(poster_output_folder, filename)
    
    create_poster(
        story_shape_paths=story_files,
        poster_width_in=poster_w_inches, poster_height_in=poster_h_inches,
        output_path=output_file_path,
        base_rows=base_r_template, base_cols=base_c_template,
        grid_template=grid_def_template,
        dpi=print_dpi, 
        margin_in=poster_general_margin_in, 
        spacing_in=grid_cell_spacing_in,
        background_color='#F0F0F0', 
        # Text Block
        poster_title=main_title_text,
        poster_title_font_path=title_font_path_config, 
        poster_title_font_size_pt=title_font_size_config,
        poster_title_font_color=title_color_config, 
        poster_subtitle=subtitle_text_config,
        poster_subtitle_font_path=subtitle_font_path_config,
        poster_subtitle_font_size_pt=subtitle_font_size_config,
        poster_subtitle_font_color=subtitle_color_config,
        text_block_v_align=text_alignment,
        text_edge_padding_in=padding_from_edge_in,
        space_between_texts_in=padding_between_texts_in,
        space_text_grid_in=padding_text_to_grid_in
    )

    print(f"\nCheck '{poster_output_folder}' for '{filename}'.")
    # You would also update create_layout_preview with similar text block logic if you use it.

# ==============================================================================
#  CONTENTS FROM: create.py
# ==============================================================================

from google.oauth2.service_account import Credentials
import gspread
import yaml
import json 
import os
import re
import time 



def pango_font_exists(font_name):
    from gi.repository import Pango, PangoCairo
    """
    Checks whether the given font is available using Pango.
    Returns True if the font is found, False otherwise.
    """
    if not font_name:
        return True  # nothing to check if font_name is empty

    # Get the default font map from PangoCairo.
    font_map = PangoCairo.FontMap.get_default()
    families = font_map.list_families()

    # Iterate through the font families and see if any name matches (case-insensitive).
    for family in families:
        if font_name.lower() in family.get_name().lower():
            return True

    return False

# ==============================================================================
#           UNIFIED PATH CONFIGURATION (for Local & Colab)
# ==============================================================================
import os
import sys

# This dictionary will hold all our configured paths
PATHS = {}

# Check if we are running in the Google Colab environment
if 'google.colab' in sys.modules:
    print("Running in Google Colab environment.")
    from google.colab import drive
    drive.mount('/content/drive')
    
    # Set the base directory to the project folder in your Google Drive
    BASE_DIR = '/content/drive/My Drive/'
    
else:
    print("Running in a local environment.")
    # Set the base directory to the project folder on your local machine
    # You will need to update this path based on where your Google Drive folder is located.
    # --- FIND YOUR LOCAL GOOGLE DRIVE PATH AND UPDATE THE LINE BELOW ---
    
    # Example for macOS:
    local_drive_path = os.path.expanduser('~/Library/CloudStorage/GoogleDrive-johnmike@theshapesofstories.com/My Drive')
    if not os.path.exists(local_drive_path): # Fallback for older Google Drive versions
        local_drive_path = '/Volumes/GoogleDrive/My Drive'

    # Example for Windows:
    # local_drive_path = 'G:\\My Drive' # Use a raw string or double backslashes
    
    #BASE_DIR = os.path.join(local_drive_path, 'Projects/TheShapesOfStories')
    BASE_DIR = local_drive_path

# --- Define all other paths relative to the base directory ---
PATHS['src'] = os.path.join(BASE_DIR, 'src')
PATHS['summaries'] = os.path.join(BASE_DIR, 'data', 'summaries')
PATHS['story_data'] = os.path.join(BASE_DIR, 'data', 'story_data')
PATHS['shapes_output'] = os.path.join(BASE_DIR, 'data', 'story_shapes')
PATHS['posters_output'] = os.path.join(BASE_DIR, 'data', 'posters')
PATHS['config'] = os.path.join(BASE_DIR, 'config.yaml')

# --- Automatically create output directories if they don't exist ---
os.makedirs(PATHS['story_data'], exist_ok=True)
os.makedirs(PATHS['shapes_output'], exist_ok=True)
os.makedirs(PATHS['posters_output'], exist_ok=True)

# --- Add the 'src' directory to the system path ---
# This allows your scripts to import from each other using "from llm import ..."
sys.path.append(PATHS['src'])

# --- Verify that the base directory exists ---
if not os.path.exists(BASE_DIR):
    raise FileNotFoundError(f"The base directory was not found at: {BASE_DIR}\n"
                            "Please check your path configuration for the current environment.")

print(f"\nProject Base Directory: {BASE_DIR}")
print("All paths configured successfully.")


import math # ensure math is imported if if component['space_to_modify'] >t already

def get_scaled_print_parameters(new_width_in, new_height_in, dpi=300):
    """
    Calculates scaled parameters for print products based on a new width and height,
    using an 8x10 print as the reference.

    Args:
        new_width_in (int): The width of the new print product in inches.
        new_height_in (int): The height of the new print product in inches.
        dpi (int): Dots per inch for pixel calculations.

    Returns:
        dict: A dictionary containing all necessary scaled parameters.
    """
    base_width_in = 8
    base_height_in = 10

    # Base parameters from the 8x10 print product
    base_params = {
        "line_thickness": 26,          # pixels (at 300 DPI for 8x10)
        "font_size": 12,               # points
        "title_font_size": 32,         # points
        "gap_above_title": 70,         # pixels (at 300 DPI for 8x10)
        "protagonist_font_size": 16,   # points
        "author_font_size": 16,        # points
        "top_text_font_size": 12,      # points (used if wrap_in_inches > 0)
        "bottom_text_font_size": 12,   # points (used if wrap_in_inches > 0)
        "top_and_bottom_text_band": 1.0, # inches (used if wrap_in_inches > 0)
        "border_thickness": 75,        # pixels (not used if has_border=False for prints)
        "wrap_in_inches": 0,           # Prints typically have no wrap
        "max_num_steps": 2,
        "step_k": 6,
        "has_border": False,           # Prints typically don't have a drawn border like canvas
        "fixed_margin_in_inches": 0.6
    }

    # Handle the 8x10 (or 10x8) case directly
    is_base_size_portrait = (new_width_in == base_width_in and new_height_in == base_height_in)
    is_base_size_landscape = (new_width_in == base_height_in and new_height_in == base_width_in) # e.g. 10x8

    if is_base_size_portrait or is_base_size_landscape:
        params_to_return = base_params.copy()
        params_to_return["width_in_inches"] = new_width_in
        params_to_return["height_in_inches"] = new_height_in
        return params_to_return

    # Scaling factor based on the shorter dimension relative to the base's shorter dimension (8 inches)
    base_ref_dim = min(base_width_in, base_height_in)  # 8 inches
    new_ref_dim = min(new_width_in, new_height_in)

    if new_ref_dim <= 0 or base_ref_dim <= 0: # Avoid division by zero or nonsensical scaling
        scaling_factor = 1.0
    else:
        scaling_factor = new_ref_dim / base_ref_dim

    scaled_params = {}

    # Scale font sizes (points) - apply minimums
    scaled_params["font_size"] = max(6, round(base_params["font_size"] * scaling_factor))
    scaled_params["title_font_size"] = max(10, round(base_params["title_font_size"] * scaling_factor))
    scaled_params["protagonist_font_size"] = max(7, round(base_params["protagonist_font_size"] * scaling_factor))
    scaled_params["author_font_size"] = max(7, round(base_params["author_font_size"] * scaling_factor))
    scaled_params["top_text_font_size"] = max(6, round(base_params["top_text_font_size"] * scaling_factor))
    scaled_params["bottom_text_font_size"] = max(6, round(base_params["bottom_text_font_size"] * scaling_factor))

    # Scale pixel-defined values based on general scaling_factor
    scaled_params["line_thickness"] = max(10, round(base_params["line_thickness"] * scaling_factor))

    # Scale gap_above_title proportionally to the title font size change (in pixels)
    base_title_font_px = base_params["title_font_size"] * (dpi / 96.0) # Points to pixels
    new_title_font_px = scaled_params["title_font_size"] * (dpi / 96.0)
    
    gap_font_ratio = new_title_font_px / base_title_font_px if base_title_font_px > 0 else scaling_factor
    scaled_params["gap_above_title"] = max(15, round(base_params["gap_above_title"] * gap_font_ratio))

    # Scale inch-defined values
    scaled_params["top_and_bottom_text_band"] = max(0.25, base_params["top_and_bottom_text_band"] * scaling_factor)
    scaled_params["fixed_margin_in_inches"] = max(0.25, base_params["fixed_margin_in_inches"] * scaling_factor)

    # Scale max_num_steps (integer, visual density)
    scaled_max_steps = base_params["max_num_steps"] * scaling_factor
    if scaled_max_steps < 1.5: # If new size is significantly smaller
        scaled_params["max_num_steps"] = 1
    else: # Allow it to scale up slightly, but often 2 is good for prints.
        scaled_params["max_num_steps"] = min(3, round(scaled_max_steps)) # Cap at 3 for prints

    # Parameters typically fixed for "print" products or directly copied
    scaled_params["step_k"] = base_params["step_k"]
    scaled_params["border_thickness"] = base_params["border_thickness"] # Not used if has_border=False
    scaled_params["has_border"] = base_params["has_border"]
    scaled_params["wrap_in_inches"] = base_params["wrap_in_inches"] # Should be 0 for prints

    # Assign new width and height
    scaled_params["width_in_inches"] = new_width_in
    scaled_params["height_in_inches"] = new_height_in
    
    return scaled_params

# # Load credentials from the YAML file
# def load_credentials_from_yaml(file_path):
#     with open(file_path, "r") as yaml_file:
#         config = yaml.safe_load(yaml_file)
#     return config["google_sheets"]

# CONFIG_FILE = "/Users/johnmikedidonato/Projects/TheShapesOfStories/config.yaml"
# creds_data = load_credentials_from_yaml(CONFIG_FILE)

# Load credentials from the YAML file
def load_credentials_from_yaml(file_path):
    with open(file_path, "r") as yaml_file:
        config = yaml.safe_load(yaml_file)
    return config["google_sheets"]

# Use the configured path from the PATHS dictionary
creds_data = load_credentials_from_yaml(PATHS['config'])

# Define the correct scope
SCOPES = ["https://www.googleapis.com/auth/spreadsheets.readonly"]

# Create credentials with the correct scope
credentials = Credentials.from_service_account_info(creds_data, scopes=SCOPES)

# Authorize and create a client
client = gspread.authorize(credentials)

# Open the Google Sheet by its ID
#link https://docs.google.com/spreadsheets/d/1T0ThSHKK_sMIKTdwC14WZoWFNFD3dU7xIheQ5AF9NLU/edit?usp=sharing
sheet_id = "1T0ThSHKK_sMIKTdwC14WZoWFNFD3dU7xIheQ5AF9NLU"
spreadsheet = client.open_by_key(sheet_id)
worksheet = spreadsheet.sheet1 # Access the first worksheet


# Get all rows from the sheet
rows = worksheet.get_all_records()

#loop through all rows but really should just be first row
for row in rows:
    print("starting...")
    start_time = time.perf_counter()
    # Assign each column value to a variable
    product = row.get("product")
    size = row.get("size")
    print(size)
    line_type = row.get("line_type")
    file_format = row.get("file_format")
    title = str(row.get("title"))
    author = row.get("author")
    protagonist = row.get("protagonist")
    year = row.get("year")
    summary_file = row.get("summary_file")
    background_color = row.get("background_color (optional)")
    font_color = row.get("font_color (optional)")
    border_color = row.get("border_color (optional)")
    font = row.get("font (optional)")
    width = row.get("width (in) (optional)")
    height = row.get("height (in) (optional)")
    subtitle = row.get("subtitle (optional)")

    #if style not fully specified then get style for story
    if background_color == "" or font_color == "" or border_color == "" or font == "":

        story_style = get_story_style(
            story_title = title, 
            author = author,
            protagonist = protagonist, 
            llm_provider = "anthropic", #google", 
            llm_model = "claude-3-5-sonnet-latest" #"gemini-2.5-pro-preview-03-25"
        )
        story_style = json.loads(story_style)
        design_rationale = story_style.get('design_rationale')

        print(design_rationale)

        if background_color == "":
            background_color = story_style.get('background_color')
            print("background color set to: ", background_color)
        else:
            print("background color manual override set to: ", background_color)

        if font_color == "":
            font_color = story_style.get('font_color')
            print("font color set to: ", font_color)
        else:
            print("font color manual override set to: ", font_color)

        if border_color == "":
            border_color = story_style.get('border_color')
            print("border color set to: ", border_color)
        else:
            print("border color manual override set to: ", border_color)

        if font == "":
            font = story_style.get('font')
            print("font set to: ", font)
        else:
            print("font manual override set to: ", font)
        
    else:
        print("story style provided")


    #CHECK ABOUT FONT
    if 'google.colab' in sys.modules:
        # 2. Use the `find_font` function to get the correct internal name
        #    (This function was created in the cell above)
        desired_family = font
        font = find_font(font) #find font is function that exists in collab notebook only

        # 3. Check if a font was found and then use it
        if font:
            print(f"Request: ('{desired_family}') -> Found best match: '{font}'")
            
        else:
            print(f"ERROR: Could not find a suitable font for '{desired_family}'"
                "Please check the library table in the cell above for available fonts.")
            #next create story data
    else:
        if font and not pango_font_exists(font):
            raise ValueError(f"'{font}' not found on this system.")


    # Normalize the title to replace curly apostrophes with straight ones
    title = title.replace("’", "'")  # Normalize typographic apostrophes
    title = title.replace(",", "")
    
    #we should check if exsits first if not then create it 
    # story_data_output_path_base = "/Users/johnmikedidonato/Projects/TheShapesOfStories/data/story_data/"
    # potential_story_data_file_path = title.lower().replace(' ', '-') + "_" + protagonist.lower().replace(' ', '-')
    # check_path = story_data_output_path_base + potential_story_data_file_path + ".json"
    
    # Check if story data exists first, if not then create it 
    potential_story_data_file_path = title.lower().replace(' ', '-') + "_" + protagonist.lower().replace(' ', '-')
    # Use the configured path
    check_path = os.path.join(PATHS['story_data'], potential_story_data_file_path + ".json")
    print(check_path)

    if os.path.exists(check_path):
        story_data_path = check_path
        print("story data exists")
    else:
        #print("couldnt find")
        print("story data did not exist")
        story_data, story_data_path = create_story_data(config_path = PATHS['config'],
            summary_dir = PATHS['summaries'],
            summary_file=summary_file,
            author=author, 
            year=year, 
            protagonist=protagonist,
            #output_path = story_data_output_path_base,
            output_path = PATHS['story_data'], # <-- CORRECTED
            llm_provider =  "google", #"openai",#, #"openai",, #"anthropic", #google", 
            llm_model = "gemini-2.5-pro-preview-06-05", #o3-mini-2025-01-31", #"o4-mini-2025-04-16" #"gemini-2.5-pro-preview-05-06" #"o3-2025-04-16" #"gemini-2.5-pro-preview-05-06"#o3-2025-04-16"#"gemini-2.5-pro-preview-05-06" #"claude-3-5-sonnet-latest" #"gemini-2.5-pro-preview-03-25"
            )

    ### YOU JUST NEED 12x12 and then you shrinnk it down 
    # size     | 6x6 | 12x12 | 10x10 | 8x10
    # wrap     | 1.5 | 3     | 1.5   |  ?
    # t/b band | 1.5 | 1.5   | 1.5   |  ?
    # ----------------------------------
    # arc      | 8   | 16    | 14    |  12
    # title    | 24  | 48    | 40    |  32
    # protag   | 12  | 24    | 20    |  16
    # top      | 24  | 48    | 20    |  16
    # bottom   | 6   | 12    | 12    |  12
    #-----------------------------------
    # line     | 20  | 40    | 33    |  26
    # border   | ?   | 150   | 150   |  150
    # gap      | 20  | 40    | 33    |
    #-----------------------------------

    if product == "canvas" and size == "12x12":
        line_thickness = 40
        font_size = 16
        title_font_size = 48
        gap_above_title = 40
        protagonist_font_size = 24
        author_font_size = 24
        top_text = author + ", " + str(year)
        top_text_font_size = 48
        bottom_text_font_size = 12
        top_and_bottom_text_band = 1.5
        border_thickness = 150
        width_in_inches = 12
        height_in_inches = 12
        wrap_in_inches = 3
        max_num_steps = 3
        step_k = 10
        has_border = True
        fixed_margin_in_inches = 0.6
    elif product == "canvas" and size == "10x10":
        line_thickness = 33
        font_size = 14
        title_font_size = 40
        gap_above_title = 33
        protagonist_font_size = 20
        author_font_size = 20
        top_text = author + ", " + str(year)
        top_text_font_size = 20
        bottom_text_font_size = 12
        top_and_bottom_text_band = 1
        border_thickness = 150 #use thicker border
        width_in_inches = 10
        height_in_inches = 10
        wrap_in_inches = 1.5
        max_num_steps = 3
        step_k = 10
        has_border = True
        fixed_margin_in_inches = 0.6
    elif product == "print" and size == "8x10":
        line_thickness = 26
        font_size = 12
        title_font_size = 32 #value is 32, other values: 26, 22, 20 (very small)
        gap_above_title = 70 #value was 26
        protagonist_font_size = 16
        author_font_size = 16
        top_text = author + ", " + str(year)
        top_text_font_size = 12
        bottom_text_font_size = 12
        top_and_bottom_text_band = 1
        border_thickness = 75 #use thinner border 
        width_in_inches = 8
        height_in_inches = 10
        wrap_in_inches = 0
        max_num_steps = 2
        step_k = 6
        has_border = False
        fixed_margin_in_inches = 0.6
    elif product == "print" and size == "custom":
        print_params = get_scaled_print_parameters(width, height)
        
        line_thickness = print_params["line_thickness"]
        font_size = print_params["font_size"]
        title_font_size = print_params["title_font_size"]
        gap_above_title = print_params["gap_above_title"]
        protagonist_font_size = print_params["protagonist_font_size"]
        author_font_size = print_params["author_font_size"]
        top_text_font_size = print_params["top_text_font_size"]
        bottom_text_font_size = print_params["bottom_text_font_size"]
        top_and_bottom_text_band = print_params["top_and_bottom_text_band"]
        border_thickness = print_params["border_thickness"]
        width_in_inches = print_params["width_in_inches"]
        height_in_inches = print_params["height_in_inches"]
        wrap_in_inches = print_params["wrap_in_inches"]
        max_num_steps = print_params["max_num_steps"]
        step_k = print_params["step_k"]
        has_border = print_params["has_border"]
        fixed_margin_in_inches = print_params["fixed_margin_in_inches"]


        top_text = ""

    else:
        raise ValueError


    print("creating story shape")
    new_story_data_path, story_shape_path = create_shape(
                    config_path = PATHS['config'],
                    output_dir = PATHS['shapes_output'], # <-- ADD THIS LINE
                    story_data_dir=PATHS['story_data'],      # For reading/writing data files
                    story_data_path = story_data_path,
                    product = product,
                    x_delta= 0.015,#0.015, #number of points in the line 
                    step_k = step_k, #step-by-step steepness; higher k --> more steepness; values = 3, 4.6, 6.9, 10, 15
                    max_num_steps = max_num_steps,
                    line_type = line_type, #values line or char
                    line_thickness = line_thickness, #only used if line_type = line
                    line_color = font_color, #only used if line_type = line
                    font_style= font, #only used if line_type set to char
                    font_size= font_size, #only used if line_type set to char
                    font_color = font_color, #only used if line_type set to char
                    background_type='solid', #values solid or transparent
                    background_value = background_color, #only used if background_type = solid
                    has_title = "YES", #values YES or NO
                    title_text = "", #optinal if left blank then will use story title as default
                    title_font_style = font, #only used if has_title = "YES"
                    title_font_size=title_font_size, #only used if has_title = "YES"
                    title_font_color = font_color, #only used if has_title = "YES"
                    title_font_bold = False, #can be True or False
                    title_font_underline = False, #can be true or False
                    title_padding = 0, #extra padding in pixels between bottom and title
                    gap_above_title=gap_above_title, #padding in pixels between title and story shape
                    protagonist_text = protagonist, #if you leave blank will include protognaist name in lower right corner; can get rid of by just setting to " ", only works if has title is true
                    protagonist_font_style = font,
                    protagonist_font_size=protagonist_font_size, 
                    protagonist_font_color=font_color,
                    protagonist_font_bold = False, #can be True or False
                    protagonist_font_underline = False, #can be True or False

                    author_text=subtitle, # Optional, defaults to story_data['author']
                    author_font_style=font, # Defaults to title font style if empty
                    author_font_size=author_font_size, # Suggest smaller than title
                    author_font_color=font_color, # Use hex, defaults to title color
                    author_font_bold=False,
                    author_font_underline=False,
                    author_padding=5, 

                    top_text = top_text, #only applies when wrapped > 0; if "" will default to author, year
                    top_text_font_style = font,
                    top_text_font_size = top_text_font_size,
                    top_text_font_color = font_color,
                    bottom_text = "", #only applies when wrapped > 0; if "" will default to "Shapes of Stories"
                    bottom_text_font_style = "Sans",
                    bottom_text_font_size = bottom_text_font_size,
                    bottom_text_font_color = "#000000",
                    top_and_bottom_text_band = top_and_bottom_text_band, #this determines the band which top and center text is centered on above/below design; if you want to center along full wrap in inches set value to wrap_in_inches else standard is 1.5 
                    border=has_border, #True or False
                    border_thickness= border_thickness, #only applicable if border is set to True
                    border_color=border_color, #only applicable if border is set to True
                    width_in_inches = width_in_inches,  #design width size
                    height_in_inches = height_in_inches, #design width size
                    wrap_in_inches=wrap_in_inches,  # for canvas print outs 
                    wrap_background_color = border_color, #wrapped in inches part color only relevant when wrap_in_inches > 0 inc
                    fixed_margin_in_inches = fixed_margin_in_inches, #fixed margins for output
                    recursive_mode = True, #if you want to recurisvely generate story
                    recursive_loops = 500, #the number of iterations 
                    llm_provider = "anthropic",#"groq",#"openai", #anthropic",#"google" #for generating descriptors
                    llm_model = "claude-3-5-sonnet-latest",#"meta-llama/llama-4-scout-17b-16e-instruct",#"gpt-4.1-2025-04-14", #"claude-3-5-sonnet-latest",#"gemini-2.5-pro-preview-03-25", #"claude-3-5-sonnet-latest", #for generating descriptors 
                    #llm_provider = "google", #"anthropic", #google", 
                    #llm_model = "gemini-2.5-pro-preview-05-06", #"claude-3-5-sonnet-latest" #"gemini-2.5-pro-preview-03-25"
                    output_format=file_format
                ) #options png or svg
    end_time = time.perf_counter()
    elapsed_time = end_time - start_time
    print(f"The script took {elapsed_time:.4f} seconds to execute.")


